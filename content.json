[{"title":"mysql 索引结构","date":"2018-07-19T04:34:14.000Z","path":"2018/07/19/mysql索引/","text":"mysql 索引结构 Inoodb 优化原则： 永远用小结果集驱动大结果集 只取出自己需要的字段(1.数据量 2.排序占用) 使用最有效的过滤条件 避免复杂的查询 MyISAM Join 12/*查看join buffer 大小*/SHOW VARIABLES LIKE '%join%' 优化原则： 永远用小结果集驱动大结果集 保证驱动表上的join条件字段已经被索引 调整Join Buffer(join_buffer_size)大小(空间换时间) OrderBy 123/*查看join buffer 大小*/SHOW VARIABLES LIKE '%sort%' SHOW VARIABLES LIKE '%max_length_for_sort_data%' 优化原则： 索引顺序一致的话不需要在排序 加大max_length_for_sort_data,把数据跟需要排序的字段放到内存中处理后一起返回。 加大innodb_sort_buffer_size(空间换时间) GroupByGroupBy是在OrderBy的基础上进行的 所以优化与OrderBy同理 DistinctDistinct是在GroupBy的基础上进行的 所以优化与OrderBy同理","tags":[{"name":"mysql","slug":"mysql","permalink":"http://lj360560179.github.io/tags/mysql/"}]},{"title":"dubbo 调用流程","date":"2018-06-25T07:44:14.000Z","path":"2018/06/25/dubbo/","text":"dubbo调用简要流程图 dubbo的十个层 大致流程","tags":[{"name":"java","slug":"java","permalink":"http://lj360560179.github.io/tags/java/"}]},{"title":"线程按顺序执行","date":"2018-06-12T07:25:00.000Z","path":"2018/06/12/线程按顺序执行/","text":"线程按顺序执行 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * @Author lj * @Date 2018/6/11 20:18 */public class ThreadTest &#123; public static class Thread1 extends Thread&#123; @Override public void run() &#123; System.out.println(1); &#125; &#125; public static class Thread2 extends Thread&#123; @Override public void run() &#123; System.out.println(2); &#125; &#125; public static class Thread3 extends Thread&#123; @Override public void run() &#123; System.out.println(3); &#125; &#125; public static void main(String[] args) throws Exception&#123; ThreadSx(); ThreadSx2(); &#125; private static void ThreadSx() &#123; ExecutorService service = Executors.newSingleThreadExecutor(); service.submit(()-&gt;System.out.println(1)); service.submit(()-&gt;System.out.println(2)); service.submit(()-&gt;System.out.println(3)); service.shutdown(); &#125; private static void ThreadSx2() throws Exception&#123; Thread1 t1 = new Thread1(); Thread2 t2 = new Thread2(); Thread3 t3 = new Thread3(); t1.start(); t1.join(); t2.start(); t2.join(); t3.start(); t3.join(); &#125;&#125; 线程按顺序循环执行synchronized123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/** * @Author lj * @Date 2018/6/12 11:04 */public class ThreadTest2 &#123; private static volatile int s = 1; public static class Thread1 extends Thread &#123; @Override public void run() &#123; synchronized (ThreadTest2.class) &#123; for (int i = 0; i &lt; 10;) &#123; if (s == 1) &#123; System.out.println(1); s = 2; i++; ThreadTest2.class.notifyAll(); &#125; else &#123; try &#123; ThreadTest2.class.wait(); &#125; catch (Exception e) &#123; &#125; &#125; &#125; &#125; &#125; &#125; public static class Thread2 extends Thread &#123; @Override public void run() &#123; synchronized (ThreadTest2.class) &#123; for (int i = 0; i &lt; 10;) &#123; if (s == 2) &#123; System.out.println(2); s = 3; i++; ThreadTest2.class.notifyAll(); &#125; else &#123; try &#123; ThreadTest2.class.wait(); &#125; catch (Exception e) &#123; &#125; &#125; &#125; &#125; &#125; &#125; public static class Thread3 extends Thread &#123; @Override public void run() &#123; synchronized (ThreadTest2.class) &#123; for (int i = 0; i &lt; 11;) &#123; if (s == 3) &#123; System.out.println(3); s = 1; i++; ThreadTest2.class.notifyAll(); &#125; else &#123; try &#123; ThreadTest2.class.wait(); &#125; catch (Exception e) &#123; &#125; &#125; &#125; &#125; &#125; &#125; public static void main(String[] args)throws Exception &#123; Thread1 t1 = new Thread1(); Thread2 t2 = new Thread2(); Thread3 t3 = new Thread3(); t1.start(); t2.start(); t3.start(); &#125;&#125; ReentrantLock12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * @Author lj * @Date 2018/6/12 13:44 */public class ThreadTest3 &#123; private static ReentrantLock lock = new ReentrantLock(); private static volatile int s = 1; public static class Thread1 extends Thread&#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; ) &#123; lock.lock(); if (s == 1) &#123; System.out.println(1); s = 2; i++; &#125; lock.unlock(); &#125; &#125; &#125; public static class Thread2 extends Thread&#123; @Override public void run() &#123; for (int i = 0; i &lt; 10;) &#123; lock.lock(); if (s == 2) &#123; System.out.println(2); s = 3; i++; &#125; lock.unlock(); &#125; &#125; &#125; public static class Thread3 extends Thread&#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; ) &#123; lock.lock(); if (s == 3) &#123; System.out.println(3); s = 1; i++; &#125; lock.unlock(); &#125; &#125; &#125; public static void main(String[] args)throws Exception &#123; new Thread1().start(); new Thread2().start(); new Thread3().start(); &#125;&#125; Condition1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/** * @Author lj * @Date 2018/6/12 14:10 */public class ThreadTest4 &#123; private static volatile int s = 1; private static ReentrantLock lock = new ReentrantLock(); private static Condition condition1 = lock.newCondition(); private static Condition condition2 = lock.newCondition(); private static Condition condition3 = lock.newCondition(); private static class Thread1 extends Thread &#123; @Override public void run() &#123; lock.lock(); try &#123; for (int i = 0; i &lt; 10; ) &#123; if (s != 1) &#123; condition1.await(); &#125; else &#123; System.out.println(1); s=2; i++; condition2.signal(); &#125; &#125; &#125; catch (Exception e) &#123; &#125; finally &#123; lock.unlock(); &#125; &#125; &#125; private static class Thread2 extends Thread &#123; @Override public void run() &#123; lock.lock(); try &#123; for (int i = 0; i &lt; 10; ) &#123; if (s != 2) &#123; condition2.await(); &#125; else &#123; System.out.println(2); s=3; i++; condition3.signal(); &#125; &#125; &#125; catch (Exception e) &#123; &#125; finally &#123; lock.unlock(); &#125; &#125; &#125; private static class Thread3 extends Thread &#123; @Override public void run() &#123; lock.lock(); try &#123; for (int i = 0; i &lt; 10; ) &#123; if (s != 3) &#123; condition3.await(); &#125; else &#123; System.out.println(3); s=1; i++; condition1.signal(); &#125; &#125; &#125; catch (Exception e) &#123; &#125; finally &#123; lock.unlock(); &#125; &#125; &#125; public static void main(String[] args) &#123; new Thread1().start(); new Thread2().start(); new Thread3().start(); &#125;&#125; Semaphore12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * @Author lj * @Date 2018/6/12 14:26 */public class ThreadTest5 &#123; private static Semaphore semaphore1 = new Semaphore(1); private static Semaphore semaphore2 = new Semaphore(1); private static Semaphore semaphore3 = new Semaphore(1); private static class Thread1 extends Thread&#123; @Override public void run() &#123; try &#123; for(int i=0;i&lt;10;i++)&#123; semaphore1.acquire(); System.out.println(1); semaphore2.release(); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125; private static class Thread2 extends Thread&#123; @Override public void run() &#123; try &#123; for(int i=0;i&lt;10;i++)&#123; semaphore2.acquire(); System.out.println(2); semaphore3.release(); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125; private static class Thread3 extends Thread&#123; @Override public void run() &#123; try &#123; for(int i=0;i&lt;10;i++)&#123; semaphore3.acquire(); System.out.println(3); semaphore1.release(); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) throws Exception &#123; semaphore2.acquire(); semaphore3.acquire(); new Thread1().start(); new Thread2().start(); new Thread3().start(); &#125;&#125;","tags":[{"name":"java","slug":"java","permalink":"http://lj360560179.github.io/tags/java/"}]},{"title":"线程模型","date":"2018-04-25T07:44:14.000Z","path":"2018/04/25/线程模型/","text":"线程模型简单记录 用户级线程模型 （1-N） 内核级线程 （1-1） 对于官方JDK来说，因为Windwos和Linux操作系统（主流）只提供一对一线程模型 ，所以SUN JDK采用了一对一线程模型 。其它JDK可以有不同实现（如Solaris JDK可以采用N对M模型）。 组合方式 （N-M） golang线程模型MPG M-P-G三者关系 M-P-G模型 M-P-G切换 M-P-G均衡的分配工作","tags":[{"name":"go","slug":"go","permalink":"http://lj360560179.github.io/tags/go/"}]},{"title":"ES写入查询流程","date":"2018-04-23T07:44:14.000Z","path":"2018/04/23/ES写入查询流程图/","text":"简单记录下ES写入查询流程 流程图","tags":[{"name":"java","slug":"java","permalink":"http://lj360560179.github.io/tags/java/"},{"name":"ES","slug":"ES","permalink":"http://lj360560179.github.io/tags/ES/"}]},{"title":"Docker搭建ELK","date":"2018-03-25T07:44:14.000Z","path":"2018/03/25/docker搭建elk/","text":"ELK由Elasticsearch、Logstash和Kibana三部分组件组成。 安装docker安装docker elk安装前提 Docker至少得分配3GB的内存； Elasticsearch至少需要单独2G的内存； 防火墙开放相关端口，执行以下命令开放相关端口； 123firewall-cmd --zone=public --add-port=5601/tcp --permanent;firewall-cmd --reload;firewall-cmd --zone=public --add-port=9200/tcp --permanent;firewall-cmd --reload;firewall-cmd --zone=public --add-port=5044/tcp --permanent;firewall-cmd --reload; vm.max_map_count至少需要262144，附永久修改vm.max_map_count操作以下命令更改配置： 1234cd /etcvi sysctl.conf 增加以下属性后退出保存： vm.max_map_count=262144 pull elk镜像1docker pull sebp/elk 该镜像包含了elk三个部分，比较方便，也可以单独拉起每个部分的镜像分开部署 启动 elk1docker run -d -p 5601:5601 -p 9200:9200 -p 5044:5044 -it --name elk sebp/elk 启动要一会,使用命令查看容器是否正常运行1docker ps 可以看到容器已经正常启动，打开浏览器，输入：http://你的ip:5601，看到如下界面说明安装成功，只是还没有数据 配置使用命令以下进入容器内，并执行命令1234docker exec -it elk /bin/bash #测试/opt/logstash/bin/logstash --path.data /tmp/logstash/data -e 'input &#123; stdin &#123; &#125; &#125; output &#123; elasticsearch &#123; hosts =&gt; [\"localhost\"] &#125; &#125;' 运行后等一会，出现下图则说明成功按配置启动logstash,测试命令的意思是配置 以命令行输入logstash,然后传输到elasticsearch,然后随便输入一下测试数据再次打开Kibana可以看到已经有数据，然后让你配置，按提示配置后去Discover就能看到刚才的数据如果看到这样的报错信息 Logstash could not be started because there is already another instance using the configured data directory. If you wish to run multiple instances, you must change the “path.data” setting. 请执行命令：service logstash stop 然后在执行就可以了。 使用filebeat收集日志Filebeat是一个日志文件托运工具，在你的服务器上安装客户端后，filebeat会监控日志目录或者指定的日志文件，追踪读取这些文件（追踪文件的变化，不停的读），并且转发这些信息到elasticsearch或者logstarsh中存放。因为项目是跑在docker中，可能不再一个虚拟机上，在一台虚拟机也不再同一个容器中，所以需要通过docker volumes将docker中的日志文件挂载到虚拟机上的一个目录，然后每台虚拟机使用filebeat来收集日志然后发送到logstash，当然logstash还有其他方式传输日志，比如redis，kafka等。如下图 配置logstash使用filebeat需要修改logstash配置文件，默认的就是使用beat输入1cd /etc/logstash/conf.d 配置文件在容器中的conf.d目录下，修改目录下的02-beats-input.conf文件123456input &#123; beats &#123; port =&gt; 5044 client_inactivity_timeout =&gt; 36000 &#125;&#125; client_inactivity_timeout为客户端连接超时时间,将证书的配置删除，如果你要配置证书，在filebeat也要配置，logstash配置还能做很多处理，比如grok解析需要的可以去官网查看详细信息，修改成后重启docker 容器 1docker restart elk 安装filebeat下载filebeat镜像1docker pull prima/filebeat 启动前要配置filebeat.yml123456789101112131415161718192021222324252627282930313233343536373839404142434445###################### Filebeat Configuration Example ########################## You can find the full configuration reference here:# https://www.elastic.co/guide/en/beats/filebeat/index.htmlfilebeat.prospectors:- type: log enabled: true #配置filebeat要读取的log文件路径，有多个的话可以使用通配符或者多个paths节点配置 paths: - /var/lib/docker/volumes/home/logs/service/*.log tags: [\"service\"] multiline: pattern: ^\\d&#123;4&#125; negate: true match: after fields: doc_type: service - type: log enabled: true paths: - /var/lib/docker/volumes/home/logs/app/*.log tags: [\"app\"] multiline: pattern: ^\\d&#123;4&#125; negate: true match: after fields: doc_type: app - type: log enabled: true paths: - /var/lib/docker/volumes/home/logs/center/*.log tags: [\"center\"] multiline: pattern: ^\\d&#123;4&#125; negate: true match: after fields: doc_type: center setup.kibana:output.logstash: hosts: [\"127.0.0.1:5044\"] logging.metrics.enabled: false 上面是一个简单的列子，可以去官网看详细配置 然后启动filebeat1docker run -d --name filebeat -v /home/filebeat/filebeat.yml:/filebeat.yml -v /var/lib/docker/volumes/:/var/lib/docker/volumes/ -v /home/filebeat/module:/module --net=host prima/filebeat 启动成功后配置文件中的监视目录下的日志文件就会传输到logstash中","tags":[{"name":"docker","slug":"docker","permalink":"http://lj360560179.github.io/tags/docker/"}]},{"title":"MQ使用场景","date":"2018-02-25T07:44:14.000Z","path":"2018/02/25/mq使用场景/","text":"简单记录下消息队列的使用场景，以及优缺点还有使用中需要注意的问题。 常见MQ对比 MQ使用场景解耦分布式系统时经常会有某个系统调用其他系统的情况，如下图，用户下了一个订单，会在订单系统生成记录，然后用户系统要添加积分，商品系统需要修改销量库存等一系列操作，在没引入消息队列前，各系统间耦合严重，每当修改需求，其他系统不需要订单系统的数据，或者又有新的系统需要订单系统的数据，则每次都要修改订单系统的代码。引入消息队列后，其他系统只需要订阅队列，订单系统则可以不管其他系统如何操作，从而使各系统解耦。 异步在没有引入MQ前，因为是同步的，所以用户一个请求需要等待所有系统调用成功后才能返回结果，引入MQ后，用户完成下订单操作后就可以直接返回，不用等待其他系统的操作，降低了该请求的耗时。 削峰当并发量很大的时候，如果程序直接写数据库，数据库会宕机，这时候引入MQ来进行削峰，先把请求写入MQ中，当高峰期后在消费队列中的数据，以防数据库宕机。 MQ产生的问题系统复杂度引入MQ，会使系统复杂度大大提高，要额外的维护MQ，而且一般生产环境不会只部署一个MQ服务，为了可用性，都会部署多台MQ做集群。 系统可用性引入MQ后，如果MQ服务挂了，那整个系统就挂了，所以为了防止某个MQ宕机导致系统挂掉，一般都会做MQ集群，主流的MQ都提供了集群部署模式。 重复数据一般MQ都会存在出现重复数据的情况，所以要保证系统不重复消费数据，一般都要在消费方操作前查询该消息是否被消费。并且把自动提交已消费改成手动提交，例如kafka自动提交offset改成手动提交，在消息消费成功后手动提交。 消息丢失如图，生产者P向队列中生产消息，C1和C2消费队列中的消息，默认情况下，MQ会平均的分发消费给C1C2（Round-robin dispatching），假设一个任务的执行时间非常长，在执行过程中，客户端挂了（连接断开），那么，该客户端正在处理且未完成的消息，以及分配给它还没来得及执行的消息，都将丢失。因为默认情况下，MQ分发完消息后，就会从内存中把消息删除掉。 通常的解决办法是使用消息确认机制。基本每个MQ都用类似的机制配置。 消息堆积如果消费方出现了BUG，消息就会堆积在消息队列中，堆积到消息队列承载的极限，准备挂的时候，通常此时就应该增加机器，然后把原来队列中的数据分发到临时的队列中，然后添加多个消费方来快速消费数据。 按顺序执行有时候消息需要按顺序消费，可以以某个字段来分发到同一个队列中。消费方如果需要使用多线程来消费，则可以新建临时的内存队列，同理以某个字段分组放到同一个内存队列中消费","tags":[{"name":"java","slug":"java","permalink":"http://lj360560179.github.io/tags/java/"}]},{"title":"jvm常用命令","date":"2017-06-16T16:34:14.000Z","path":"2017/06/17/性能监控/","text":"常用命令系统性能监控 确定系统运行的整体状态，基本定位问题所在Java自带的工具 查看Java程序运行细节，进一步定位问题 系统性能监控 linuxuptime 连接数 每一个终端算一个连接1，5，15分钟内的系统平均负载 运行队列中的平均进程数 topvmstat 可以统计系统的CPU，内存，swap，io等情况 pidstat 细致观察进程 需要安装( sudo apt-get install sysstat) 监控CPU 监控IO 监控内存 -p 指定进程 –u 监控CPU 每秒采样 一共3次 Java自带的工具jps 列出java进程，类似于ps命令. 参数-q可以指定jps只输出进程ID ，不输出类的短名称. 参数-m可以用于输出传递给Java进程（主函数）的参数. 参数-l可以用于输出主函数的完整路径. 参数-v可以显示传递给JVM的参数. jinfo 可以用来查看正在运行的Java应用程序的扩展参数，甚至支持在运行时，修改部分参数 -flag ：打印指定JVM的参数值 -flag [+|-]：设置指定JVM参数的布尔值 -flag =：设置指定JVM参数的值 jmap 生成Java应用程序的堆快照和对象的统计信息 jmap -histo 2972 &gt;c:\\s.txt Dump堆 jmap -dump:format=b,file=c:\\heap.hprof 2972 jstack 打印线程dump -l 打印锁信息 -m 打印java和native的帧信息 -F 强制dump，当jstack没有响应时使用 内存溢出(OOM)的原因在JVM中，有哪些内存区间？ 堆 永久区 线程栈 直接内存 堆溢出1234567public static void main(String args[])&#123; ArrayList&lt;byte[]&gt; list=new ArrayList&lt;byte[]&gt;(); for(int i=0;i&lt;1024;i++)&#123; list.add(new byte[1024*1024]); &#125;&#125;//占用大量的堆空间，直接溢出 12Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap spaceat geym.jvm.ch8.oom.SimpleHeapOOM.main(SimpleHeapOOM.java:14) 解决方法：增大堆空间，及时释放内存 永久区123456//生成大量的类public static void main(String[] args) &#123; for(int i=0;i&lt;100000;i++)&#123; CglibBean bean = new CglibBean(\"geym.jvm.ch3.perm.bean\"+i,new HashMap()); &#125;&#125; 增大Perm区、允许Class回收 Java栈溢出 这里的栈溢出指，在创建线程的时候，需要为线程分配栈空间，这个栈空间是向操作系统请求的，如果操作系统无法给出足够的空间，就会抛出OOM 12345678910111213141516public static class SleepThread implements Runnable&#123; public void run()&#123; try &#123; Thread.sleep(10000000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;public static void main(String args[])&#123; for(int i=0;i&lt;1000;i++)&#123; new Thread(new SleepThread(),\"Thread\"+i).start(); System.out.println(\"Thread\"+i+\" created\"); &#125;&#125; 1-Xmx1g -Xss1m Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: unable to create new native thread 解决方法：减少堆内存减少线程栈大小 直接内存溢出 ByteBuffer.allocateDirect()无法从操作系统获得足够的空间","tags":[{"name":"java","slug":"java","permalink":"http://lj360560179.github.io/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://lj360560179.github.io/tags/jvm/"}]},{"title":"GC相关","date":"2017-06-13T16:00:00.000Z","path":"2017/06/14/GC参数/","text":"GC 参数堆的回顾 GC参数 - 串行收集器 最古老，最稳定 效率高 可能会产生较长的停顿 -XX:+UseSerialGC 新生代、老年代使用串行回收 新生代复制算法 老年代标记-压缩 GC参数 -并行收集器ParNew收集器 -XX:+UseParNewGC() 新生代并行 老年代串行 Serial收集器新生代的并行版本 复制算法 多线程，需要多核支持 -XX:ParallelGCThreads 限制线程数量 多线程不一定快哦！ Parallel收集器 类似ParNew 新生代复制算法 老年代 标记-压缩 更加关注吞吐量 XX:+UseParallelGC 使用Parallel收集器 + 老年代串行 XX:+UseParallelOldGC 使用Parallel收集器 + 并行老年代 -XX:MaxGCPauseMills 最大停顿时间，单位毫秒 GC尽力保证回收时间不超过设定值 -XX:GCTimeRatio 0-100的取值范围 垃圾收集时间占总时间的比 默认99，即最大允许1%时间做GC 这两个参数是矛盾的。因为停顿时间和吞吐量不可能同时调优 CMS收集器CMS收集器 Concurrent Mark Sweep 并发标(与用户线程一起执行)记清除 标记-清除算法 与标记-压缩相比 并发阶段会降低吞吐量 老年代收集器（新生代使用ParNew） XX:+UseConcMarkSweepGCCMS运行过程比较复杂，着重实现了标记的过程，可分为 初始标记 根可以直接关联到的对象 速度快 并发标记（和用户线程一起） 主要标记过程，标记全部对象 重新标记 由于并发标记时，用户线程依然运行，因此在正式清理前，再做修正 并发清除（和用户线程一起） 基于标记结果，直接清理对象 特点 尽可能降低停顿 会影响系统整体吞吐量和性能 比如，在用户线程运行过程中，分一半CPU去做GC，系统性能在GC阶段，反应速度就下降一半 清理不彻底 因为在清理阶段，用户线程还在运行，会产生新的垃圾，无法清理 因为和用户线程一起运行，不能在空间快满时再清理 -XX:CMSInitiatingOccupancyFraction设置触发GC的阈值 如果不幸内存预留空间不够，就会引起concurrent mode failure 使用串行收集器作为后备 有关碎片 标记-清除和标记-压缩 -XX:+ UseCMSCompactAtFullCollection Full GC后，进行一次整理 整理过程是独占的，会引起停顿时间变长 -XX:+CMSFullGCsBeforeCompaction 设置进行几次Full GC后，进行一次碎片整理 -XX:ParallelCMSThreads 设定CMS的线程数量 GC参数整理-XX:+UseSerialGC：在新生代和老年代使用串行收集器-XX:SurvivorRatio：设置eden区大小和survivior区大小的比例 //8:1:1-XX:NewRatio:新生代和老年代的比-XX:+UseParNewGC：在新生代使用并行收集器-XX:+UseParallelGC ：新生代使用并行回收收集器-XX:+UseParallelOldGC：老年代使用并行回收收集器-XX:ParallelGCThreads：设置用于垃圾回收的线程数-XX:+UseConcMarkSweepGC：新生代使用并行收集器，老年代使用CMS+串行收集器(作为担保)-XX:ParallelCMSThreads：设定CMS的线程数量-XX:CMSInitiatingOccupancyFraction：设置CMS收集器在老年代空间被使用多少后触发-XX:+UseCMSCompactAtFullCollection：设置CMS收集器在完成垃圾收集后是否要进行一次内存碎片的整理-XX:CMSFullGCsBeforeCompaction：设定进行多少次CMS垃圾回收后，进行一次内存压缩-XX:+CMSClassUnloadingEnabled：允许对类元数据进行回收-XX:CMSInitiatingPermOccupancyFraction：当永久区占用率达到这一百分比时，启动CMS回收-XX:UseCMSInitiatingOccupancyOnly：表示只在到达阀值的时候，才进行CMS回收","tags":[{"name":"java","slug":"java","permalink":"http://lj360560179.github.io/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://lj360560179.github.io/tags/jvm/"},{"name":"GC","slug":"GC","permalink":"http://lj360560179.github.io/tags/GC/"}]},{"title":"GC算法与种类","date":"2017-06-12T16:34:14.000Z","path":"2017/06/13/GC算法和种类/","text":"GC 算法与种类 GC的概念 GC算法 引用计数法 标记清除 标记压缩 复制算法 可触及性 Stop-The-World GC的概念 Garbage Collection 垃圾收集 1960年 List 使用了GC Java中，GC的对象是堆空间和永久区 引用计数法 老牌垃圾回收算法 通过引用计算来回收垃圾 使用者 COM ActionScript3 Python 引用计数器的实现很简单，对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1，当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，则对象A就不可能再被使用。 引用计数法的问题 引用和去引用伴随加法和减法，影响性能 很难处理循环引用 标记-清除标记-清除算法是现代垃圾回收算法的思想基础。标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。一种可行的实现是，在标记阶段，首先通过根节点，标记所有从根节点开始的可达对象。因此，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有未被标记的对象。 标记-压缩标记-压缩算法适合用于存活对象较多的场合，如老年代。它在标记-清除算法的基础上做了一些优化。和标记-清除算法一样，标记-压缩算法也首先需要从根节点开始，对所有可达对象做一次标记。但之后，它并不简单的清理未标记的对象，而是将所有的存活对象压缩到内存的一端。之后，清理边界外所有的空间。 标记压缩对标记清除而言，有什么优势呢？复制算法与标记-清除算法相比，复制算法是一种相对高效的回收方法不适用于存活对象较多的场合 如老年代将原有的内存空间分为两块，每次只使用其中一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收 复制算法的最大问题是：空间浪费 整合标记清理思想 -XX:+PrintGCDetails的输出 分代思想依据对象的存活周期进行分类，短命对象归为新生代，长命对象归为老年代。根据不同代的特点，选取合适的收集算法 少量对象存活，适合复制算法 大量对象存活，适合标记清理或者标记压缩 GC算法总结整理 引用计数 没有被Java采用 标记-清除 标记-压缩 复制算法 新生代 所有的算法，需要能够识别一个垃圾对象，因此需要给出一个可触及性的定义 可触及性 可触及的 从根节点可以触及到这个对象 可复活的 一旦所有引用被释放，就是可复活状态 因为在finalize()中可能复活该对象 不可触及的 在finalize()后，可能会进入不可触及状态 不可触及的对象不可能复活 可以回收 123456789101112131415161718192021222324252627282930313233343536public class CanReliveObj &#123; public static CanReliveObj obj; @Override protected void finalize() throws Throwable &#123; super.finalize(); System.out.println(\"CanReliveObj finalize called\"); obj = this; &#125; @Override public String toString() &#123; return \"I am CanReliveObj\"; &#125; public static void main(String[] args) throws InterruptedException &#123; obj = new CanReliveObj(); obj = null; // 可复活 System.gc(); Thread.sleep(1000); if (obj == null) &#123; System.out.println(\"obj 是 null\"); &#125; else &#123; System.out.println(\"obj 可用\"); &#125; System.out.println(\"第二次gc\"); obj = null; // 不可复活 System.gc(); Thread.sleep(1000); if (obj == null) &#123; System.out.println(\"obj 是 null\"); &#125; else &#123; System.out.println(\"obj 可用\"); &#125; &#125;&#125; 经验：避免使用finalize()，操作不慎可能导致错误。 优先级低，何时被调用， 不确定 何时发生GC不确定 可以使用try-catch-finally来替代它 根 栈中引用的对象 方法区中静态成员或者常量引用的对象（全局对象） JNI方法栈中引用对象 Stop-The-World Java中一种全局暂停的现象 全局停顿，所有Java代码停止，native代码可以执行，但不能和JVM交互 多半由于GC引起(Dump线程、死锁检查、堆Dump) GC时为什么会有全局停顿？ 类比在聚会时打扫房间，聚会时很乱，又有新的垃圾产生，房间永远打扫不干净，只有让大家停止活动了，才能将房间打扫干净。 危害 长时间服务停止，没有响应 遇到HA系统，可能引起主备切换，严重危害生产环境。 123456789101112131415public static class PrintThread extends Thread&#123; public static final long starttime=System.currentTimeMillis(); @Override public void run()&#123; try&#123; while(true)&#123; long t=System.currentTimeMillis()-starttime; System.out.println(\"time:\"+t); Thread.sleep(100); &#125; &#125;catch(Exception e)&#123; &#125; &#125;&#125; 1-Xmx512M -Xms512M -XX:+UseSerialGC -Xloggc:gc.log -XX:+PrintGCDetails -Xmn1m -XX:PretenureSizeThreshold=50 -XX:MaxTenuringThreshold=1 123456789101112131415161718192021public static class MyThread extends Thread&#123; HashMap&lt;Long,byte[]&gt; map=new HashMap&lt;Long,byte[]&gt;(); @Override public void run()&#123; try&#123; while(true)&#123; if(map.size()*512/1024/1024&gt;=450)&#123;//大于450M时，清理内存 System.out.println(\"=====准备清理=====:\" +map.size()); map.clear(); &#125; //工作线程，消耗内存 for(int i=0;i&lt;1024;i++)&#123; map.put(System.nanoTime(), new byte[512]); &#125; Thread.sleep(1); &#125; &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125;","tags":[{"name":"java","slug":"java","permalink":"http://lj360560179.github.io/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://lj360560179.github.io/tags/jvm/"},{"name":"GC","slug":"GC","permalink":"http://lj360560179.github.io/tags/GC/"}]},{"title":"常用JVM配置参数","date":"2017-06-11T16:34:14.000Z","path":"2017/06/12/jvm参数设置/","text":"常用JVM配置参数Trace跟踪参数 -verbose:gc -XX:+printGC 可以打印GC的简要信息 [GC 4790K-&gt;374K(15872K), 0.0001606 secs][GC 4790K-&gt;374K(15872K), 0.0001474 secs][GC 4790K-&gt;374K(15872K), 0.0001563 secs][GC 4790K-&gt;374K(15872K), 0.0001682 secs] -XX:+PrintGCDetails 打印GC详细信息 -XX:+PrintGCTimeStamps 打印CG发生的时间戳 例：[GC[DefNew: 4416K-&gt;0K(4928K), 0.0001897 secs] 4790K-&gt;374K(15872K), 0.0002232 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] -XX:+PrintGCDetails的输出 -Xloggc:log/gc.log 指定GC log的位置，以文件输出帮助开发人员分析问题 -XX:+PrintHeapAtGC 每次一次GC后，都打印堆信息 -XX:+TraceClassLoading监控类的加载 [Loaded java.lang.Object from shared objects file][Loaded java.io.Serializable from shared objects file][Loaded java.lang.Comparable from shared objects file][Loaded java.lang.CharSequence from shared objects file][Loaded java.lang.String from shared objects file][Loaded java.lang.reflect.GenericDeclaration from shared objects file][Loaded java.lang.reflect.Type from shared objects file] -XX:+PrintClassHistogram 按下Ctrl+Break后，打印类的信息： 分别显示：序号、实例数量、总大小、类型 堆的分配参数 -Xmx –Xms指定最大堆和最小堆-Xmx20m -Xms5m 运行代码： 12345678System.out.print(\"Xmx=\");System.out.println(Runtime.getRuntime().maxMemory()/1024.0/1024+\"M\");System.out.print(\"free mem=\");System.out.println(Runtime.getRuntime().freeMemory()/1024.0/1024+\"M\");System.out.print(\"total mem=\");System.out.println(Runtime.getRuntime().totalMemory()/1024.0/1024+\"M\"); Xmx=19.375Mfree mem=4.342750549316406Mtotal mem=4.875M 1234567891011byte[] b=new byte[1*1024*1024];System.out.println(\"分配了1M空间给数组\");System.out.print(\"Xmx=\");System.out.println(Runtime.getRuntime().maxMemory()/1024.0/1024+\"M\");System.out.print(\"free mem=\");System.out.println(Runtime.getRuntime().freeMemory()/1024.0/1024+\"M\");//Java会尽可能维持在最小堆System.out.print(\"total mem=\");System.out.println(Runtime.getRuntime().totalMemory()/1024.0/1024+\"M\"); 分配了1M空间给数组Xmx=19.375Mfree mem=3.4791183471679688Mtotal mem=4.875M 1234567891011b=new byte[4*1024*1024];System.out.println(\"分配了4M空间给数组\");System.out.print(\"Xmx=\");System.out.println(Runtime.getRuntime().maxMemory()/1024.0/1024+\"M\");System.out.print(\"free mem=\");System.out.println(Runtime.getRuntime().freeMemory()/1024.0/1024+\"M\");System.out.print(\"total mem=\");System.out.println(Runtime.getRuntime().totalMemory()/1024.0/1024+\"M\"); 分配了4M空间给数组Xmx=19.375Mfree mem=3.5899810791015625Mtotal mem=9.00390625M &lt;– 可以看到总内存变多了 1234567891011System.gc(); System.out.println(\"回收内存\");System.out.print(\"Xmx=\");System.out.println(Runtime.getRuntime().maxMemory()/1024.0/1024+\"M\");System.out.print(\"free mem=\");System.out.println(Runtime.getRuntime().freeMemory()/1024.0/1024+\"M\");System.out.print(\"total mem=\");System.out.println(Runtime.getRuntime().totalMemory()/1024.0/1024+\"M\"); 回收内存Xmx=19.375Mfree mem=6.354591369628906M &lt;—可以看到空闲内存增加total mem=10.75390625M -Xmn 设置新生代大小 -XX:NewRatio 新生代（eden+2*s）和老年代（不包含永久区）的比值 4 表示 新生代:老年代=1:4，即年轻代占堆的1/5 -XX:SurvivorRatio 设置两个Survivor区和eden的比 8表示 两个Survivor :eden=2:8，即一个Survivor占年轻代的1/10 12345public static void main(String[] args) &#123; byte[] b=null; for(int i=0;i&lt;10;i++) b=new byte[1*1024*1024];&#125; 1-Xmx20m -Xms20m -Xmn1m -XX:+PrintGCDetails 1.没有触发GC2.全部分配在老年代 1-Xmx20m -Xms20m -Xmn15m -XX:+PrintGCDetails 1.没有触发GC2.全部分配在eden3.老年代没有使用 1-Xmx20m -Xms20m –Xmn7m -XX:+PrintGCDetails 1.进行了2次新生代GC2.s0 s1 太小需要老年代担保 1-Xmx20m -Xms20m -Xmn7m -XX:SurvivorRatio=2 -XX:+PrintGCDetails 1.进行了3次新生代GC2.s0 s1 增大 -XX:+HeapDumpOnOutOfMemoryErrorOOM时导出堆到文件 -XX:+HeapDumpPath导出OOM的路径 -Xmx20m -Xms5m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=d:/a.dump -XX:OnOutOfMemoryError在OOM时，执行一个脚本“-XX:OnOutOfMemoryError=D:/tools/jdk1.7_40/bin/printstack.bat %p“当程序OOM时，在D:/a.txt中将会生成线程的dump可以在OOM时，发送邮件，甚至是重启程序 堆的分配参数 – 总结 根据实际事情调整新生代和幸存代的大小 官方推荐新生代占堆的3/8 幸存代占新生代的1/10 在OOM时，记得Dump出堆，确保可以排查现场问题 永久区分配参数-XX:PermSize -XX:MaxPermSize 设置永久区的初始空间和最大空间他们表示，一个系统可以容纳多少个类型 使用CGLIB等库的时候，可能会产生大量的类，这些类，有可能撑爆永久区导致OOM 1234//不断产生新的类for(int i=0;i&lt;100000;i++)&#123; CglibBean bean = new CglibBean(\"geym.jvm.ch3.perm.bean\"+i,new HashMap());&#125; 打开堆的Dump -堆空间实际占用非常少-但是永久区溢出 一样抛出OOM 如果堆空间没有用完也抛出了OOM，有可能是永久区导致的 栈大小分配 -Xss 通常只有几百K 决定了函数调用的深度 每个线程都有独立的栈空间 局部变量、参数 分配在栈上 12345678910111213141516public class TestStackDeep &#123; private static int count=0; public static void recursion(long a,long b,long c)&#123; long e=1,f=2,g=3,h=4,i=5,k=6,q=7,x=8,y=9,z=10; count++; recursion(a,b,c); &#125; public static void main(String args[])&#123; try&#123; recursion(0L,0L,0L); &#125;catch(Throwable e)&#123; System.out.println(\"deep of calling = \"+count); e.printStackTrace(); &#125; &#125;&#125; 12345678//递归调用//-Xss128K//deep of calling = 701java.lang.StackOverflowError-Xss256K//deep of calling = 1817java.lang.StackOverflowError","tags":[{"name":"java","slug":"java","permalink":"http://lj360560179.github.io/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://lj360560179.github.io/tags/jvm/"}]},{"title":"JVM机制运行原理","date":"2017-06-10T16:34:14.000Z","path":"2017/06/11/jvm运行机制/","text":"jvm启动流程 jvm基本结构 PC寄存器 每个线程拥有一个PC寄存器 在线程创建时 创建 指向下一条指令的地址 执行本地方法时，PC的值为undefined 方法区保存装载的类信息 类型的常量池 字段，方法信息 方法字节码 类的全限定名(类的全路径名)类的直接超类的全限定名(如果这个类是Object,则它没有超类)这个类是类型(类)还是接口类的访问修饰符,如public、abstract、final等所有的直接接口全限定名的有序列表(假如它实现了多个接口)常量池：字段、方法信息、类变量信息(静态变量)装载该类的装载器的引用(classLoader)、类型引用(class)通常和永久区(Perm)关联在一起 Java堆 和程序开发密切相关 应用系统对象都保存在Java堆中 所有线程共享Java堆 对分代GC来说，堆也是分代的 GC的主要工作区间 eden : s0 : s1 = 8 : 1 : 1 Java栈 线程私有 栈由一系列帧组成（因此Java栈也叫做帧栈） 帧保存一个方法的局部变量、操作数栈、常量池指针 每一次方法调用创建一个帧，并压栈 操作数栈Java没有寄存器，所有参数传递使用操作数栈 12345public static int add(int a,int b)&#123; int c=0; c=a+b; return c;&#125; 123456780: iconst_0 // 0压栈1: istore_2 // 弹出int，存放于局部变量22: iload_0 // 把局部变量0压栈3: iload_1 // 局部变量1压栈4: iadd //弹出2个变量，求和，结果压栈5: istore_2 //弹出结果，放于局部变量26: iload_2 //局部变量2压栈7: ireturn //返回 栈上分配1234567891011121314public class OnStackTest &#123; public static void alloc()&#123; byte[] b=new byte[2]; b[0]=1; &#125; public static void main(String[] args) &#123; long b=System.currentTimeMillis(); for(int i=0;i&lt;100000000;i++)&#123; alloc(); &#125; long e=System.currentTimeMillis(); System.out.println(e-b); &#125;&#125; 12-server -Xmx10m -Xms10m-XX:+DoEscapeAnalysis -XX:+PrintGC 输出结果 5 12-server -Xmx10m -Xms10m -XX:-DoEscapeAnalysis -XX:+PrintGC ……[GC 3550K-&gt;478K(10240K), 0.0000977 secs][GC 3550K-&gt;478K(10240K), 0.0001361 secs][GC 3550K-&gt;478K(10240K), 0.0000963 secs]564 小对象（一般几十个bytes），在没有逃逸的情况下，可以直接分配在栈上 直接分配在栈上，可以自动回收，减轻GC压力 大对象或者逃逸对象无法栈上分配 栈、堆、方法区交互 12345678910111213141516171819202122232425public class AppMain &#123; //运行时, jvm 把appmain的信息都放入方法区 public static void main(String[] args)&#123; //main 方法本身放入方法区。 Sample test1 = new Sample(\" 测试 1\"); //test1是引用，所以放到栈区里， Sample是自定义对象应该放到堆里面 Sample test2 = new Sample(\" 测试 2\"); test1.printName(); test2.printName(); &#125;&#125;public class Sample&#123; //运行时, jvm 把appmain的信息都放入方法区 private name; //new Sample实例后，name 引用放入栈区里，name 对象放入堆里 public Sample(String nam)&#123; this.name = name; &#125; //print方法本身放入 方法区里。 public void printName()&#123; System.out.print(name); &#125;&#125; 内存模型 每一个线程有一个工作内存和主存独立 工作内存存放主存中变量的值的拷贝 当数据从主内存复制到工作存储时，必须出现两个动作： 第一，由主内存执行的读（read）操作； 第二，由工作内存执行的相应的load操作；当数据从工作内存拷贝到主内存时，也出现两个操作：第一个，由工作内存执行的存储（store）操作；第二，由主内存执行的相应的写（write）操作 每一个操作都是原子的，即执行期间不会被中断 对于普通变量，一个线程中更新的值，不能马上反应在其他变量中,如果需要在其他线程中立即可见，需要使用 volatile 关键字 可见性 一个线程修改了变量，其他线程可以立即知道 保证可见性的方法 volatile synchronized （unlock之前，写变量值回主存） final(一旦初始化完成，其他线程就可见) 有序性 在本线程内，操作都是有序的 在线程外观察，操作都是无序的。（指令重排 或 主内存同步延时） 指令重排 线程内串行语义 123456写后读 a = 1;b = a; 写一个变量之后，再读这个位置。写后写 a = 1;a = 2; 写一个变量之后，再写这个变量。读后写 a = b;b = 1; 读一个变量之后，再写这个变量。以上语句不可重排编译器不考虑多线程间的语义可重排： a=1;b=2; 指令重排的基本原则 (happen-before) 程序顺序原则：一个线程内保证语义的串行性 volatile规则：volatile变量的写，先发生于读 锁规则：解锁(unlock)必然发生在随后的加锁(lock)前 传递性：A先于B，B先于C 那么A必然先于C 线程的start方法先于它的每一个动作 线程的所有操作先于线程的终结（Thread.join()） 线程的中断（interrupt()）先于被中断线程的代码 对象的构造函数执行结束先于finalize()方法 解释运行 解释执行以解释方式运行字节码 解释执行的意思是：读一句执行一句 编译运行（JIT） 将字节码编译成机器码 直接执行机器码 运行时编译 编译后性能有数量级的提升","tags":[{"name":"java","slug":"java","permalink":"http://lj360560179.github.io/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://lj360560179.github.io/tags/jvm/"}]},{"title":"锁优化","date":"2017-06-06T16:34:14.000Z","path":"2017/06/07/锁优化/","text":"锁优化的思路和方法锁优化的思路和方法 减少锁持有时间 减小锁粒度 锁分离 锁粗化 锁消除 减少锁持有时间12345public synchronized void syncMethod()&#123; othercode1(); mutextMethod(); othercode2();&#125; 1234567public void syncMethod2()&#123; othercode1(); synchronized(this)&#123; mutextMethod(); &#125; othercode2();&#125; 减小锁粒度 将大对象，拆成小对象，大大增加并行度，降低锁竞争 偏向锁，轻量级锁成功率提高 例子：ConcurrentHashMap 与 HashMap的同步实现 HashMap的同步实现12345678Collections.synchronizedMap(Map&lt;K,V&gt; m//返回SynchronizedMap对象public V get(Object key) &#123; synchronized (mutex) &#123;return m.get(key);&#125; &#125;public V put(K key, V value) &#123; synchronized (mutex) &#123;return m.put(key, value);&#125;&#125; ConcurrentHashMap 123若干个Segment ：Segment&lt;K,V&gt;[] segmentsSegment中维护HashEntry&lt;K,V&gt;put操作时,先定位到Segment，锁定一个Segment，执行put 在减小锁粒度后， ConcurrentHashMap允许若干个线程同时进入 锁分离 根据功能进行锁分离 ReadWriteLock 读多写少的情况，可以提高性能 读写分离思想可以延伸，只要操作互不影响，锁就可以分离，例如： LinkedBlockingQueue 队列 链表 锁粗化通常情况下，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽量短，即在使用完公共资源后，应该立即释放锁。只有这样，等待在这个锁上的其他线程才能尽早的获得资源执行任务。但是，凡事都有一个度，如果对同一个锁不停的进行请求、同步和释放，其本身也会消耗系统宝贵的资源，反而不利于性能的优化 123456789public void demoMethod()&#123; synchronized(lock)&#123; //do sth. &#125; //做其他不需要的同步的工作，但能很快执行完毕 synchronized(lock)&#123; //do sth. &#125;&#125; ==&gt;修改后 1234567public void demoMethod()&#123; //整合成一次锁请求 synchronized(lock)&#123; //do sth. //做其他不需要的同步的工作，但能很快执行完毕 &#125;&#125; 12345for(int i=0;i&lt;CIRCLE;i++)&#123; synchronized(lock)&#123; &#125;&#125; ==&gt;修改后 12345synchronized(lock)&#123; for(int i=0;i&lt;CIRCLE;i++)&#123; &#125;&#125; 锁消除在即时编译器时，如果发现不可能被共享的对象，则可以消除这些对象的锁操作 1234567891011121314public static void main(String args[]) throws InterruptedException &#123; long start = System.currentTimeMillis(); for (int i = 0; i &lt; CIRCLE; i++) &#123; craeteStringBuffer(\"JVM\", \"Diagnosis\"); &#125; long bufferCost = System.currentTimeMillis() - start; System.out.println(\"craeteStringBuffer: \" + bufferCost + \" ms\");&#125;public static String craeteStringBuffer(String s1, String s2) &#123; StringBuffer sb = new StringBuffer(); sb.append(s1);//同步操作 sb.append(s2);//同步操作 return sb.toString();&#125; CIRCLE= 2000000 1-server -XX:+DoEscapeAnalysis -XX:+EliminateLocks //craeteStringBuffer: 187 ms 1-server -XX:+DoEscapeAnalysis -XX:-EliminateLocks //craeteStringBuffer: 254 ms 虚拟机内的锁优化对象头MarkMark Word，对象头的标记，32位描述对象的hash、锁信息，垃圾回收标记，年龄 指向锁记录的指针 指向monitor的指针 GC标记 偏向锁线程ID 偏向锁 大部分情况是没有竞争的，所以可以通过偏向来提高性能 所谓的偏向，就是偏心，即锁会偏向于当前已经占有锁的线程 将对象头Mark的标记设置为偏向，并将线程ID写入对象头Mark 只要没有竞争，获得偏向锁的线程，在将来进入同步块，不需要做同步 当其他线程请求相同的锁时，偏向模式结束 -XX:+UseBiasedLocking -默认启用 在竞争激烈的场合，偏向锁会增加系统负担 12345678910111213public static List&lt;Integer&gt; numberList =new Vector&lt;Integer&gt;();public static void main(String[] args) throws InterruptedException &#123; long begin=System.currentTimeMillis(); int count=0; int startnum=0; while(count&lt;10000000)&#123; numberList.add(startnum); startnum+=2; count++; &#125; long end=System.currentTimeMillis(); System.out.println(end-begin);&#125; 123-XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0 //启用偏向锁-XX:-UseBiasedLocking //禁用 轻量级锁BasicObjectLock – 嵌入在线程栈中的对象 普通的锁处理性能不够理想，轻量级锁是一种快速的锁定方法。如果对象没有被锁定 将对象头的Mark指针保存到锁对象中 将对象头设置为指向锁的指针（在线程栈空间中） 1234567lock-&gt;set_displaced_header(mark);//lock位于线程栈中if (mark == (markOop) Atomic::cmpxchg_ptr(lock, obj()-&gt;mark_addr(), mark))&#123; TEVENT (slow_enter: release stacklock) ; return ;&#125; 如果轻量级锁失败，表示存在竞争，升级为重量级锁（常规锁）在没有锁竞争的前提下，减少传统锁使用OS互斥量产生的性能损耗在竞争激烈时，轻量级锁会多做很多额外操作，导致性能下降 自旋锁 当竞争存在时，如果线程可以很快获得锁，那么可以不在OS层挂起线程，让线程做几个空操作（自旋） JDK1.6中-XX:+UseSpinning开启 JDK1.7中，去掉此参数，改为内置实现 如果同步块很长，自旋失败，会降低系统性能 如果同步块很短，自旋成功，节省线程挂起切换时间，提升系统性能 偏向锁，轻量级锁，自旋锁总结不是Java语言层面的锁优化方法内置于JVM中的获取锁的优化方法和获取锁的步骤 偏向锁可用会先尝试偏向锁 轻量级锁可用会先尝试轻量级锁 以上都失败，尝试自旋锁 再失败，尝试普通锁，使用OS互斥量在操作系统层挂起 一个错误使用锁的案例12345678910111213141516171819public class IntegerLock &#123; static Integer i=0; public static class AddThread extends Thread&#123; public void run()&#123; for(int k=0;k&lt;100000;k++)&#123; synchronized(i)&#123; i++; &#125; &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; AddThread t1=new AddThread(); AddThread t2=new AddThread(); t1.start();t2.start(); t1.join();t2.join(); System.out.println(i); &#125;&#125;","tags":[{"name":"java","slug":"java","permalink":"http://lj360560179.github.io/tags/java/"}]},{"title":"NIO","date":"2017-06-05T16:34:14.000Z","path":"2017/06/06/NIO/","text":"NIO什么是NIONIO是New I/O的简称，与旧式的基于流的I/O方法相对，从名字看，它表示新的一套Java I/O标准。它是在Java 1.4中被纳入到JDK中的，并具有以下特性： NIO是基于块（Block）的，它以块为基本单位处理数据 为所有的原始类型提供（Buffer）缓存支持 增加通道（Channel）对象，作为新的原始 I/O 抽象 支持锁和内存映射文件的文件访问接口 提供了基于Selector的异步网络I/O Buffer and Channel1234567891011121314151617181920212223242526272829303132public class Nio &#123; public static void nioCopyFile(String resource, String destination) throws IOException &#123; FileInputStream fis = new FileInputStream(resource); FileOutputStream fos = new FileOutputStream(destination); FileChannel readChannel = fis.getChannel(); //读文件通道 FileChannel writeChannel = fos.getChannel(); //写文件通道 ByteBuffer buffer = ByteBuffer.allocate(1024); //读入数据缓存 while (true) &#123; buffer.clear(); int len = readChannel.read(buffer); //读入数据 if (len == -1) &#123; break; //读取完毕 &#125; buffer.flip(); writeChannel.write(buffer); //写入文件 &#125; readChannel.close(); writeChannel.close(); &#125; public static void main (String[] args)&#123; NioAndAio demo = new NioAndAio(); try&#123; demo.nioCopyFile(\"E:\\\\git\\\\blog\\\\blog\\\\README.md\",\"E:\\\\git\\\\blog\\\\blog\\\\README2.md\"); &#125;catch ( IOException e)&#123; e.printStackTrace(); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public final Buffer rewind()``` 将position置零，并清除标志位（mark）```java public final Buffer clear()``` 将position置零，同时将limit设置为capacity的大小，并清除了标志mark```java public final Buffer flip()``` 先将limit设置到position所在位置，然后将position置零，并清除标志位mark通常在读写转换时使用### nio socket```java/** * @Author lj * @Date 2018/8/15 14:50 */public class NioSocketServer &#123; private Selector selector; private Charset charset = Charset.forName(\"UTF-8\"); public void init() throws Exception &#123; selector = Selector.open(); ServerSocketChannel server = ServerSocketChannel.open(); InetSocketAddress isa = new InetSocketAddress(\"127.0.0.1\", 3000); server.socket().bind(isa); server.configureBlocking(false); server.register(selector, SelectionKey.OP_ACCEPT); while (selector.select() &gt; 0) &#123; for (SelectionKey key : selector.selectedKeys()) &#123; selector.selectedKeys().remove(key); if (key.isAcceptable()) &#123; SocketChannel sc = server.accept(); sc.configureBlocking(false); //将选择器注册到连接到的客户端信道， //并指定该信道key值的属性为OP_READ， //同时为该信道指定关联的附件 sc.register(selector, SelectionKey.OP_READ); key.interestOps(SelectionKey.OP_ACCEPT); &#125; if (key.isReadable()) &#123; SocketChannel sc = (SocketChannel) key.channel(); ByteBuffer buff = ByteBuffer.allocate(1024); String content = \"\"; try &#123; while (sc.read(buff) &gt; 0) &#123; buff.flip(); content += charset.decode(buff); buff.clear(); &#125; System.out.println(\"=====\" + content); key.interestOps(SelectionKey.OP_READ); &#125; catch (IOException e) &#123; key.cancel(); if (key.channel() != null)&#123; key.channel().close(); &#125; &#125; if (content.length() &gt; 0) &#123; for (SelectionKey sk : selector.keys()) &#123; Channel targetChannel = sk.channel(); if (targetChannel instanceof SocketChannel) &#123; SocketChannel dest = (SocketChannel) targetChannel; dest.write(charset.encode(content)); &#125; &#125; &#125; else &#123; sc.close(); key.cancel(); &#125; &#125; &#125; &#125; &#125; public static void main(String[] args) throws Exception &#123; new NioSocketServer().init(); &#125;&#125;","tags":[{"name":"java","slug":"java","permalink":"http://lj360560179.github.io/tags/java/"}]},{"title":"并发设计模式","date":"2017-06-03T16:34:14.000Z","path":"2017/06/04/并发设计模式/","text":"并发设计模式什么是设计模式 在软件工程中，设计模式（design pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。 单例模式 单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为比如：全局信息配置最简单的单例模式（饿汉式）1234567891011public class Singleton&#123; //单例的构造函数都是private private Singleton()&#123; System.out.println(\"Singlenton is create\"); &#125; //static private static Singleton instance = new Singleton(); public static Singleton getInstance()&#123; return instance; &#125;&#125; 只有当访问到该类的时候才会产生实例，所以何时产生实例 不好控制。（懒汉式-加锁）12345678910111213public class LazySingleton&#123; //单例的构造函数都是private private LazySingleton()&#123; System.out.println(\"LazySingleton is create\"); &#125; private static LazySingleton instance = null; public static synchronized LazySingleton getInstance()&#123; if(instance == null)&#123; instance = new LazySingleton(); &#125; return instance; &#125;&#125; 双重检验锁12345678910111213141516171819public class LazySingleton&#123; private static volative LazySingleton instance; //单例的构造函数都是private private LazySingleton()&#123; System.out.println(\"LazySingleton is create\"); &#125; public static LazySingleton getInstance()&#123; if(instance == null)&#123; synchronized(LazySingleton.class)&#123; if(instance == null)&#123; instance = new LazySingleton(); &#125; &#125; &#125; return instance; &#125;&#125; 当有访问的时候，先判断是否有实例，如果没有再new实例，在getInstance方法加锁，防止多线程进入而创建多个实例。但是高并发的时候会有性能的问题。(线程安全-静态内部类)123456789101112public class StaticSingleton &#123; //单例的构造函数都是private private StaticSingleton()&#123; System.out.println(\"StaticSingleton is create\"); &#125; private static class SingletonHolder &#123; private static StaticSingleton instance = new StaticSingleton(); &#125; public static StaticSingleton getInstance() &#123; return SingletonHolder.instance; &#125;&#125; 枚举12345678910111213141516171819public class EnumSingleton&#123; private EnumSingleton()&#123;&#125; public static EnumSingleton getInstance()&#123; return Singleton.INSTANCE.getInstance(); &#125; private static enum Singleton&#123; INSTANCE; private EnumSingleton singleton; //JVM会保证此方法绝对只调用一次 private Singleton()&#123; singleton = new EnumSingleton(); &#125; public EnumSingleton getInstance()&#123; return singleton; &#125; &#125;&#125; 不变模式 一个类的内部状态创建后，在整个生命期间都不会发生变化时，就是不变类不变模式不需要同步123456789101112131415161718192021222324public final class Product &#123; //确保无子类 private final String no; //私有属性，不会被其他对象获取 private final String name; //final保证属性不会被2次赋值 private final double price; public Product(String no, String name, double price) &#123; //在创建对象时，必须指定数据 super(); //因为创建之后，无法进行修改 this.no = no; this.name = name; this.price = price; &#125; public String getNo() &#123; return no; &#125; public String getName() &#123; return name; &#125; public double getPrice() &#123; return price; &#125;&#125; 123456789java.lang.Stringjava.lang.Booleanjava.lang.Bytejava.lang.Characterjava.lang.Doublejava.lang.Floatjava.lang.Integerjava.lang.Longjava.lang.Short 以上的类都是不变模式的例子。“改变”都是新生成的！ Future模式核心思想是异步调用12345678910111213141516171819public class RealData implements Callable&lt;String&gt; &#123; private String para; public RealData(String para)&#123; this.para=para; &#125; @Override public String call() throws Exception &#123; StringBuffer sb=new StringBuffer(); for (int i = 0; i &lt; 10; i++) &#123; sb.append(para); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; &#125; &#125; return sb.toString(); &#125; &#125; 123456789101112131415161718192021public class FutureMain &#123; public static void main(String[] args) throws InterruptedException, ExecutionException&#123; //构造FutureTask FutureTask&lt;String&gt; future = new FutureTask&lt;String&gt;(new RealData(\"a\")); ExecutorService executor = Executors.newFixedThreadPool(1); //执行FutureTask，相当于上例中的 client.request(\"a\") 发送请求 //在这里开启线程进行RealData的call()执行 executor.submit(future); System.out.println(\"请求完毕\"); try &#123; //这里依然可以做额外的数据操作，这里使用sleep代替其他业务逻辑的处理 Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; &#125; //相当于data.getResult ()，取得call()方法的返回值 //如果此时call()方法没有执行完成，则依然会等待 System.out.println(\"数据 = \" + future.get()); &#125;&#125; 1234567891011121314151617public class FutureMain2 &#123; public static void main(String[] args) throws InterruptedException, ExecutionException &#123; ExecutorService executor = Executors.newFixedThreadPool(1); //执行FutureTask，相当于上例中的 client.request(\"a\") 发送请求 //在这里开启线程进行RealData的call()执行 Future&lt;String&gt; future=executor.submit(new RealData(\"a\")); System.out.println(\"请求完毕\"); try &#123; //这里依然可以做额外的数据操作，这里使用sleep代替其他业务逻辑的处理 Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; &#125; //相当于data.getResult ()，取得call()方法的返回值 //如果此时call()方法没有执行完成，则依然会等待 System.out.println(\"数据 = \" + future.get()); &#125;&#125; 生产者消费者模式 生产者-消费者模式是一个经典的多线程设计模式。它为多线程间的协作提供了良好的解决方案。在生产者-消费者模式中，通常由两类线程，即若干个生产者线程和若干个消费者线程。生产者线程负责提交用户请求，消费者线程则负责具体处理生产者提交的任务。生产者和消费者之间则通过共享内存缓冲区进行通信。","tags":[{"name":"java","slug":"java","permalink":"http://lj360560179.github.io/tags/java/"}]},{"title":"并发工具类","date":"2017-06-01T16:34:14.000Z","path":"2017/06/02/并发工具类/","text":"Condition类似于 Object.wait()和Object.notify()，与ReentrantLock结合使用简单列子1234567void await() throws InterruptedException;void awaitUninterruptibly();long awaitNanos(long nanosTimeout) throws InterruptedException;boolean await(long time, TimeUnit unit) throws InterruptedException;boolean awaitUntil(Date deadline) throws InterruptedException;void signal();void signalAll(); await()方法会使当前线程等待，同时释放当前锁，当其他线程中使用signal()时或者signalAll()方法时，线程会重新获得锁并继续执行。或者当线程被中断时，也能跳出等待。这和Object.wait()方法很相似。awaitUninterruptibly()方法与await()方法基本相同，但是它并不会再等待过程中响应中断。singal()方法用于唤醒一个在等待中的线程。相对的singalAll()方法会唤醒所有在等待中的线程。这和Obejct.notify()方法很类似。 123456789101112131415161718192021222324252627public class ReenterLockCondition implements Runnable&#123; public static ReentrantLock lock = new ReentrantLock(); public static Condition condition = lock.newCondition(); @Override public void run() &#123; try &#123; lock.lock();//与object.wait()一样 需要先拿到锁 condition.await(); System.out.print(\"await\"); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125; public static void main(String[] args) throws InterruptedException&#123; ReenterLockCondition tl = new ReenterLockCondition(); Thread t1 = new Thread(tl); t1.start(); Thread.sleep(5000);//延迟五秒后唤醒现成T1 lock.lock(); condition.signal(); lock.unlock(); &#125;&#125; Semaphore共享锁，运行多个线程同时临界区主要接口12345public void acquire()public void acquireUninterruptibly()public boolean tryAcquire()public boolean tryAcquire(long timeout, TimeUnit unit)public void release() 简单列子123456789101112131415161718192021222324public class SemaphoreDemo implements Runnable &#123; final Semaphore semap = new Semaphore(5); @Override public void run() &#123; try&#123; semap.acquire(); //模拟耗时操作 Thread.sleep(2000); System.out.print(Thread.currentThread().getId() + \":done!\"); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125;finally &#123; semap.release(); &#125; &#125; public static void main (String[] args)&#123; ExecutorService executorService = Executors.newFixedThreadPool(20); final SemaphoreDemo demo = new SemaphoreDemo(); for(int i=0;i&lt;20;i++)&#123; executorService.submit(demo); &#125; &#125;&#125; ReadWriteLockReadWriteLock是JDK5中提供的读写分离锁,使用与ReentrantLock相似。 读-读不互斥：读读之间不阻塞。读-写互斥：读阻塞写，写也会阻塞读。写-写互斥：写写阻塞。 123private static ReentrantReadWriteLock readWriteLock=new ReentrantReadWriteLock();private static Lock readLock = readWriteLock.readLock();private static Lock writeLock = readWriteLock.writeLock(); CountDownLatch倒数计时器主线程等待检查任务线程全部完成后执行。 123static final CountDownLatch end = new CountDownLatch(10);end.countDown();end.await(); 简单例子123456789101112131415161718192021222324252627282930public class CountDownLatchDemo implements Runnable&#123; static final CountDownLatch end = new CountDownLatch(10); static final CountDownLatchDemo demo =new CountDownLatchDemo(); @Override public void run() &#123; try&#123; //模拟检查任务 Thread.sleep(new Random().nextInt(10)*1000); System.out.println(\"check complete\"); end.countDown();//表示这个线程已经完成 &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) throws InterruptedException&#123; ExecutorService executorService = Executors.newFixedThreadPool(10); for(int i= 0;i&lt;10;i++)&#123; executorService.submit(demo); &#125; //等待检查 end.await(); //执行主线程 System.out.print(\"main Thread\"); executorService.shutdown(); &#125;&#125; CyclicBarrier循环栅栏Cyclic意为循环，也就是说这个计数器可以反复使用。比如，假设我们将计数器设置为10。那么凑齐第一批10个线程后，计数器就会归零，然后接着凑齐下一批10个线程 12public CyclicBarrier(int parties, Runnable barrierAction)//barrierAction就是当计数器一次计数完成后，系统会执行的动作await() 简单例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class CyclicBarrierDemo &#123; public static class Soldier implements Runnable&#123; private String solder; private final CyclicBarrier cyclic; Soldier(CyclicBarrier cyclic,String solderName)&#123; this.cyclic = cyclic; this.solder=solderName; &#125; public void run()&#123; try&#123; cyclic.await(); doWork(); cyclic.await(); &#125;catch (InterruptedException e)&#123;//某个线程中断后会抛异常 e.printStackTrace(); &#125;catch (BrokenBarrierException e)&#123;//其他线程也不会一直等待，会抛BrokenBarrierException e.printStackTrace(); &#125; &#125; void doWork()&#123; try&#123; Thread.sleep(Math.abs(new Random().nextInt()%10000)); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; System.out.println(solder + \":WorkEnd\"); &#125; &#125; public static class BarrierRun implements Runnable&#123; boolean flag; int N; public BarrierRun(boolean flag,int N)&#123; this.flag = flag; this.N = N; &#125; public void run()&#123; if(flag)&#123; System.out.println(\"士兵\" + N + \"个，完成\"); &#125;else&#123; System.out.println(\"士兵\" + N + \"个，集合\"); flag = true; &#125; &#125; &#125; public static void main(String args[]) throws InterruptedException&#123; final int N=10; Thread[] allSoldier = new Thread[N]; boolean flag =false; CyclicBarrier cyclicBarrier = new CyclicBarrier(N,new BarrierRun(flag,N)); System.out.println(\"集合队伍\"); for(int i=0; i&lt;N;++i)&#123; System.out.println(\"士兵\"+ i+\"报道！\"); allSoldier[i]=new Thread(new Soldier(cyclicBarrier,\"士兵\" + i)); allSoldier[i].start();// if(i == 5)&#123;// allSoldier[0].interrupt();// &#125; &#125; &#125;&#125; LockSupport提供线程阻塞原语12LockSupport.park();LockSupport.unpark(t1);","tags":[{"name":"java","slug":"java","permalink":"http://lj360560179.github.io/tags/java/"}]},{"title":"多线程基础","date":"2017-05-31T16:34:14.000Z","path":"2017/06/01/多线程基础/","text":"多线程基础 1.线程状态 新建(new)：新创建了一个线程对象。 可运行(runnable)：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu 的使用权 。 运行(running)：可运行状态(runnable)的线程获得了cpu 时间片（timeslice） ，执行程序代码。 阻塞(block)：阻塞状态是指线程因为某种原因放弃了cpu 使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice 转到运行(running)状态。阻塞的情况分三种： 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。 其他阻塞：运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。 死亡(dead)：线程run()、main() 方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。 1.实现并启动线程有两种方法 1、写一个类继承自Thread类，重写run方法。用start方法启动线程2、写一个类实现Runnable接口，实现run方法。用new Thread(Runnable target).start()方法来启动 2.Thread的 start() 和 run() 1、用start方法来启动线程，真正实现了多线程运行，这时无需等待run方法体代码执行完毕而直接继续执行下面的代码。通过调用Thread类的start()方法来启动一个线程，这时此线程处于就绪（可运行）状态，并没有运行，一旦得到cpu时间片，就开始执行run()方法，这里方法run()称为线程体，它包含了要执行的这个线程的内容，Run方法运行结束，此线程随即终止。2、run()方法只是类的一个普通方法而已，如果直接调用Run方法，程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码，这样就没有达到写线程的目的。3、调用start方法方可启动线程，而run方法只是thread的一个普通方法调用，还是在主线程里执行。 1234567891011121314public static void main(String args[]) &#123; Thread t = new Thread() &#123; public void run() &#123; test(); &#125; &#125;; t.start(); System.out.print(\"111\"); &#125; static void test() &#123; System.out.print(\"222\"); &#125; //输出111222 1234567891011121314public static void main(String args[]) &#123; Thread t = new Thread() &#123; public void run() &#123; test(); &#125; &#125;; t.run(); System.out.print(\"111\"); &#125; static void test() &#123; System.out.print(\"222\"); &#125; //输出222111 通过以上两个程序实例，可以很容易的区分出start()方法和run()方法的区别:t.start(); 该行代码相当于是启动线程，t.run(); 该行代码相当于是使用t这个类中的run方法而已. 3.stop() 暴力终止线程。 Thread.stop() 不推荐使用。它会释放所有monitor 4.中断线程123public void Thread.interrupt() // 中断线程public boolean Thread.isInterrupted() // 判断是否被中断public static boolean Thread.interrupted() // 判断是否被中断，并清除当前中断状态 123456public void run()&#123; while(true)&#123; Thread.yield(); &#125;&#125;t1.interrupt(); t1.interrupt()后并不会终止run方法的循环。12345678910public void run()&#123; while(true)&#123; if(Thread.currentThread().isInterrupted())&#123; System.out.println(\"Interruted!\"); break; &#125; Thread.yield(); &#125;&#125;t1.interrupt(); 优雅的方法应在操作数据前进行判断是否终止线程，如果已经终止则跳出循环。 4.sleep12345678910111213141516public void run()&#123; while(true)&#123; if(Thread.currentThread().isInterrupted())&#123; System.out.println(\"Interruted!\"); break; &#125; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; System.out.println(\"Interruted When Sleep\"); //设置中断状态，抛出异常后会清除中断标记位 Thread.currentThread().interrupt(); &#125; Thread.yield(); &#125;&#125; 5.挂起（suspend）和继续执行（resume）线程(不推荐使用) suspend()不会释放锁如果加锁发生在resume()之前 ，则死锁发生 6.等待线程结束（join）和谦让(yeild)12public final void join() throws InterruptedExceptionpublic final synchronized void join(long millis) throws InterruptedException 7.守护线程 在后台默默地完成一些系统性的服务，比如垃圾回收线程、JIT线程就可以理解为守护线程当一个Java应用内，只有守护线程时，Java虚拟机就会自然退出 123Thread t=new DaemonT();t.setDaemon(true);//设置为守护线程，必须在start()之前设置t.start(); 8.线程优先级123Thread t=new Thread();t.setPriority(***) //设置优先级的方法t.start(); 9.基本的线程同步操作 1、synchronized– 指定加锁对象：对给定对象加锁，进入同步代码前要获得给定对象的锁。– 直接作用于实例方法：相当于对当前实例加锁，进入同步代码前要获得当前实例的锁。– 直接作用于静态方法：相当于对当前类加锁，进入同步代码前要获得当前类的锁。2、Object.wait() Obejct.notify() 123456789101112131415public static class T1 extends Thread&#123; public void run() &#123; synchronized (object) &#123; System.out.println(System.currentTimeMillis()+\":T1 start! \"); try &#123; System.out.println(System.currentTimeMillis() +\":T1 wait for object \"); object.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(System.currentTimeMillis()+\":T1 end!\"); &#125;&#125; 12345678910111213141516public static class T2 extends Thread&#123; public void run() &#123; synchronized (object) &#123; System.out.println(System.currentTimeMillis() +\":T2 start! notify one thread\"); object.notify(); System.out.println(System.currentTimeMillis()+\":T2 end!\"); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125;&#125; synchronized (object)必须拿到锁才可以wait()、notify()，object.notify()后不会马上执行T1，需要等到object释放锁后才会继续执行。则上输出为：T1 start!T1 wait for objectT2 start! notify one threadT2 end!T1 end!//sleep(2000)后才会输出","tags":[{"name":"java","slug":"java","permalink":"http://lj360560179.github.io/tags/java/"}]},{"title":"【转】常用Linux命令","date":"2017-05-25T07:44:14.000Z","path":"2017/05/25/linux/","text":"【转】Java开发必会的Linux命令 1.查找文件1234567891011121314151617find / -name filename.txt 根据名称查找/目录下的filename.txt文件。find . -name \"*.xml\" 递归查找所有的xml文件find . -name \"*.xml\" |xargs grep \"hello world\" 递归查找所有文件内容中包含hello world的xml文件grep -H 'spring' *.xml 查找所以有的包含spring的xml文件find ./ -size 0 | xargs rm -f &amp;amp; 删除文件大小为零的文件ls -l | grep '.jar' 查找当前目录中的所有jar文件grep 'test' d* 显示所有以d开头的文件中包含test的行。grep 'test' aa bb cc 显示在aa，bb，cc文件中匹配test的行。grep '[a-z]\\&#123;5\\&#125;' aa 显示所有包含每个字符串至少有5个连续小写字符的字符串的行。 2.查看一个程序是否运行1ps –ef|grep tomcat 查看所有有关tomcat的进程 3.终止线程1kill -9 19979 终止线程号位19979的进程 4.查看文件，包含隐藏文件1ls -al 5.当前工作目录1pwd 6.复制文件12345cp source dest 复制文件cp -r sourceFolder targetFolder 递归复制整个文件夹scp sourecFile romoteUserName@remoteIp:remoteAddr 远程拷贝 7.创建目录1mkdir newfolder 8.删除目录123rmdir deleteEmptyFolder 删除空目录 rm -rf deleteFile 递归删除目录中所有内容 9.移动文件1mv /temp/movefile /targetFolder 10.重命令1mv oldNameFile newNameFile 11.切换用户1su -username 12.修改文件权限1chmod 777 file.java //file.java的权限-rwxrwxrwx，r表示读、w表示写、x表示可执行 13.压缩文件1tar -czf test.tar.gz /test1 /test2 14.列出压缩文件列表1tar -tzf test.tar.gz 15.解压文件表1tar -xvzf test.tar.gz 16.查看文件头10行1head -n 10 example.txt 17.查看文件尾10行1tail -n 10 example.txt 18.查看日志类型文件1tail -f exmaple.log //这个命令会自动显示新增内容，屏幕只显示10行内容的（可设置）。 19.使用超级管理员身份执行命令1sudo rm a.txt 使用管理员身份删除文件 20.查看端口占用情况1netstat -tln | grep 8080 查看端口8080的使用情况 21.查看端口属于哪个程序1lsof -i :8080 22.查看进程1234ps aux|grep java 查看java进程ps aux 查看所有进程 23. 文件下载123wget http://file.tgzcurl http://file.tgz","tags":[{"name":"linux","slug":"linux","permalink":"http://lj360560179.github.io/tags/linux/"}]},{"title":"github 上传","date":"2017-05-25T04:34:14.000Z","path":"2017/05/25/git/","text":"SSH key1.建立git仓库cd到你的本地项目根目录下，执行git命令1git init 2.将项目的所有文件添加到仓库中1git add . 如果想添加某个特定的文件，只需把.换成特定的文件名即可 3、将add的文件commit到仓库1git commit -m \"注释语句\" 4、去github上创建自己的Repository：去github上创建自己的Repository,拿到项目url 5、将本地的仓库关联到github上1git remote add origin https://github.com/lj360560179/xxRepository 6.上传github之前，要先pull一下，执行如下命令：12git pull origin mastergit pull origin master --allow-unrelated-histories 7.也就是最后一步，上传代码到github远程仓库1git push -u origin master 执行完后，如果没有异常，等待执行完就上传成功了，中间可能会让你输入Username和Password，你只要输入github的账号和密码就行了 Git常用命令速查手册","tags":[{"name":"github","slug":"github","permalink":"http://lj360560179.github.io/tags/github/"}]},{"title":"vue cli","date":"2017-04-25T07:44:14.000Z","path":"2017/04/25/vue-cli/","text":"vue-cli1.安装vue-cli1npm install -g vue-cli 2.使用vue-cli初始化项目1vue init webpack-simple my-project-name 3、进到目录1cd my-project 4、安装依赖1npm install 5、开始运行1npm run dev 6、测试项目–访问localhost:8080","tags":[{"name":"node.js","slug":"node-js","permalink":"http://lj360560179.github.io/tags/node-js/"},{"name":"vue.js","slug":"vue-js","permalink":"http://lj360560179.github.io/tags/vue-js/"}]},{"title":"单例模式","date":"2016-12-18T16:34:14.000Z","path":"2016/12/19/单例模式/","text":"单例模式Singleton，应用场景一般是有些对象只需要一个就够了，用来保证项目应用程序中只有一个实例，例如项目中的配置对象。 饿汉模式类加载的时候，就会创建类的唯一实例。1234567891011public class Singleton&#123; //将构造方法私有化，不允许外部直接创建对象 private Singleton()&#123; &#125; //创建类的唯一实例 private static Singleton instance=new Singleton(); //返回 public static Singleton getInstance()&#123; return instance; &#125;&#125; 懒汉模式1234567891011121314public class Singleton2&#123; //将构造方法私有化，不允许外部直接创建对象 private Singleton2()&#123; &#125; //创建类的唯一实例 private static Singleton2 instance; //返回 public static Singleton2 getInstance()&#123; if(instance==null)&#123; instance=new Singleton2(); &#125; return instance; &#125;&#125; 区别：饿汉模式的特点是加载类时比较慢，但运行时获取对象的速度比较快，线程安全的懒汉模式的特点是加载类时比较快，但运行时获取对象的速度比较慢，线程不安全的","tags":[{"name":"java","slug":"java","permalink":"http://lj360560179.github.io/tags/java/"}]},{"title":"2016-9-11.JS","date":"2016-09-11T07:44:14.000Z","path":"2016/09/11/JS/","text":"2016-9-11.JS1.typeoftypeof 运算符返回一个用来表示表达式的数据类型的字符串。typeof 运算符把类型信息当作字符串返回。typeof 返回值有六种可能： “number,” “string,” “boolean,” “object,” “function,” 和 “undefined.”其中圆括号可以加可以不加。12345678910111213typeof(1);//\"number\"typeof(NaN);//\"number\"typeof(Number.MIN_VALUE);//\"number\"typeof(Infinity);//Infinity 属性用于存放表示正无穷大的数值。\"number\"typeof(\"123\");//\"string\"typeof(true);//\"boolean\"typeof(window);//\"object\"typeof(document);//\"object\"typeof(null);//\"object\"typeof(eval);//\"function\"typeof(Date);//\"function\"typeof(sss);//\"undefined\"typeof(undefined);//\"undefined\" 使用typeof主要用来判断变量是否被定义、测试变量是否是方法。 2.confirmconfirm() 方法用于显示一个带有指定消息和 OK 及取消按钮的对话框。但是不太好看.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114// 弹框消息gwwg.h_pop_confirm = function(content,onOk)&#123; var settings = &#123; width: 260, height: 120, modal: true, ok: \"确认\", cancel: \"取消\" &#125;; if (\"undefined\" == typeof content) &#123; return false; &#125; if (\"undefined\" == typeof onOk) &#123; var onOk = null; &#125; var $dialog = $('&lt;div class=\"xxDialog\"&gt;&lt;\\/div&gt;'); var $dialogTitle; var $dialogClose = $('&lt;div class=\"dialogClose\"&gt;&lt;\\/div&gt;').appendTo($dialog); var $dialogContent; var $dialogBottom; var $dialogOk; var $dialogCancel; var $dialogOverlay; $dialogContent = $('&lt;div class=\"dialogContent\"&gt;&lt;\\/div&gt;').appendTo($dialog); if (settings.ok != null || settings.cancel != null) &#123; $dialogBottom = $('&lt;div class=\"dialogBottom\"&gt;&lt;\\/div&gt;').appendTo($dialog); &#125; if (settings.ok != null) &#123; $dialogOk = $('&lt;input type=\"button\" class=\"button\" value=\"' + settings.ok + '\" \\/&gt;').appendTo($dialogBottom); &#125; if (settings.cancel != null) &#123; $dialogCancel = $('&lt;input type=\"button\" class=\"button\" value=\"' + settings.cancel + '\" \\/&gt;').appendTo($dialogBottom); &#125; if (!window.XMLHttpRequest) &#123; $dialog.append('&lt;iframe class=\"dialogIframe\"&gt;&lt;\\/iframe&gt;'); &#125; $dialog.appendTo(\"body\"); if (settings.modal) &#123; $dialogOverlay = $('&lt;div class=\"dialogOverlay\"&gt;&lt;\\/div&gt;').insertAfter($dialog); &#125; var dialogX; var dialogY; if (settings.title != null) &#123; $dialogTitle.text(settings.title); &#125; $dialogContent.html(content); $dialog.css(&#123;\"width\": settings.width, \"height\": settings.height, \"margin-left\":parseInt(-settings.width / 2), \"z-index\": 1000&#125;); dialogShow(); if ($dialogTitle != null) &#123; $dialogTitle.mousedown(function(event) &#123; $dialog.css(&#123;\"z-index\": zIndex ++&#125;); var offset = $(this).offset(); if (!window.XMLHttpRequest) &#123; dialogX = event.clientX - offset.left; dialogY = event.clientY - offset.top; &#125; else &#123; dialogX = event.pageX - offset.left; dialogY = event.pageY - offset.top; &#125; $(\"body\").bind(\"mousemove\", function(event) &#123; $dialog.css(&#123;\"top\": event.clientY - dialogY, \"left\": event.clientX - dialogX, \"margin\": 0&#125;); &#125;); return false; &#125;).mouseup(function() &#123; $(\"body\").unbind(\"mousemove\"); return false; &#125;); &#125; if ($dialogClose != null) &#123; $dialogClose.bind(\"click\",function() &#123; dialogClose(); return false; &#125;); &#125; if ($dialogOk != null) &#123; $dialogOk.bind(\"click\",function() &#123; if (onOk &amp;&amp; typeof onOk == \"function\") &#123; dialogClose(); onOk(); &#125; else &#123; dialogClose(); &#125; return false; &#125;); &#125; if ($dialogCancel != null) &#123; $dialogCancel.bind(\"click\",function() &#123; dialogClose(); return false; &#125;); &#125; function dialogShow() &#123; $dialog.show(); $dialogOverlay.show(); &#125; function dialogClose() &#123; $dialogOverlay.remove(); $dialog.remove(); &#125; return $dialog;&#125; 大致就是画一个弹框，确认跟取消按钮，调用的时候把弹框插入body中，点击确认执行传入的回调方法。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://lj360560179.github.io/tags/javascript/"}]},{"title":"Druid简单配置","date":"2016-08-19T04:34:14.000Z","path":"2016/08/19/Druid简单配置/","text":"Druid简单配置这里只是最简单的配置，更多详细的配置可以去druid查看。 1.maven依赖12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.20&lt;/version&gt;&lt;/dependency&gt; 2.spring-dao.xml 中dataSource配置1234567891011121314151617181920212223242526272829303132333435&lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\" init-method=\"init\" destroy-method=\"close\"&gt; &lt;!-- 数据源驱动类可不写，Druid默认会自动根据URL识别DriverClass --&gt; &lt;property name=\"driverClassName\" value=\"$&#123;jdbc.driver&#125;\" /&gt; &lt;!-- 基本属性 url、user、password --&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\" /&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\" /&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\" /&gt; &lt;!-- 配置初始化大小、最小、最大 --&gt; &lt;property name=\"initialSize\" value=\"$&#123;jdbc.pool.init&#125;\" /&gt; &lt;property name=\"minIdle\" value=\"$&#123;jdbc.pool.minIdle&#125;\" /&gt; &lt;property name=\"maxActive\" value=\"$&#123;jdbc.pool.maxActive&#125;\" /&gt; &lt;!-- 配置获取连接等待超时的时间 --&gt; &lt;property name=\"maxWait\" value=\"60000\" /&gt; &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt; &lt;property name=\"timeBetweenEvictionRunsMillis\" value=\"60000\" /&gt; &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt; &lt;property name=\"minEvictableIdleTimeMillis\" value=\"300000\" /&gt; &lt;property name=\"validationQuery\" value=\"$&#123;jdbc.testSql&#125;\" /&gt; &lt;property name=\"testWhileIdle\" value=\"true\" /&gt; &lt;property name=\"testOnBorrow\" value=\"false\" /&gt; &lt;property name=\"testOnReturn\" value=\"false\" /&gt; &lt;!-- 打开PSCache，并且指定每个连接上PSCache的大小（Oracle使用） &lt;property name=\"poolPreparedStatements\" value=\"true\" /&gt; &lt;property name=\"maxPoolPreparedStatementPerConnectionSize\" value=\"20\" /&gt; --&gt; &lt;!-- 配置监控统计拦截的filters --&gt; &lt;property name=\"filters\" value=\"stat\" /&gt; &lt;/bean&gt; 3.在web.xml中配置监控页面&lt;servlet&gt; &lt;servlet-name&gt;DruidStatView&lt;/servlet-name&gt; &lt;servlet-class&gt;com.alibaba.druid.support.http.StatViewServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DruidStatView&lt;/servlet-name&gt; &lt;url-pattern&gt;/druid/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 最后打开http://localhost:8080/{youwebname}/druid/index.html 就可以看到内置监控页面。如下图。","tags":[{"name":"java","slug":"java","permalink":"http://lj360560179.github.io/tags/java/"},{"name":"数据库","slug":"数据库","permalink":"http://lj360560179.github.io/tags/数据库/"}]},{"title":"2016.8.19","date":"2016-08-19T04:34:14.000Z","path":"2016/08/19/面试记录2/","text":"1.索引的优缺点优点： 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。 可以大大加快数据的检索速度，这也是创建索引的最主要的原因。 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。 在使用分组和排序 子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。 缺点： 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。 索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。 &ensp;&ensp;索引是建立在数据库表中的某些列的上面。因此，在创建索引的时候，应该仔细考虑在哪些列上可以创建索引，在哪些列上不能创建索引。一般来说，应该在这些列上创建索引，例如： 在经常需要搜索的列上，可以加快搜索的速度； 在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构； 在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度； 在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的； 在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间； 在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。 2.int 跟 Ingter&ensp;&ensp;int与integer的区别从大的方面来说就是基本数据类型与其包装类的区别：int 是基本类型，直接存数值，而integer是对象，用一个引用指向这个对象; Java 中的数据类型分为基本数据类型和复杂数据类型,int 是前者而integer 是后者（也就是一个类）；因此在类进行初始化时int类的变量初始为0.而Integer的变量则初始化为null. 初始化的时候12int i =1；Integer i= new Integer(1);//(要把integer当做一个类看)； &ensp;&ensp;但由于有了自动装箱和拆箱，int 是基本数据类型（面向过程留下的痕迹，不过是对java的有益补充），Integer 是一个类，是int的扩展，定义了很多的转换方法，类似的还有：float Float;double Double;string String等，而且还提供了处理 int 类型时非常有用的其他一些常量和方法。举个例子：当需要往ArrayList，HashMap中放东西时，像int，double这种内建类型是放不进去的，因为容器都是装 object的，这是就需要这些内建类型的外覆类了。Java中每种内建类型都有相应的外覆类。Java中int和Integer关系是比较微妙的。关系如下： int是基本的数据类型； Integer是int的封装类； int和Integer都可以表示某一个数值； int和Integer不能够互用，因为他们两种不同的数据类型； 并且泛型定义时也不支持int: 如：List list = new ArrayList();可以 而List list = new ArrayList();则不行 3.时间日期格式1yyyy-MM-dd HH:mm:ss &gt;&gt;&gt; yyyy年MM月dd日HH时mm分ss秒 4.JDK,JRE,JVMJDK&ensp;&ensp;JDK是Java开发工具包，是Sun Microsystems针对Java开发员的产品。&ensp;&ensp;JDK中包含JRE，在JDK的安装目录下有一个名为jre的目录，里面有两个文件夹bin和lib，在这里可以认为bin里的就是jvm，lib中则是&ensp;&ensp;jvm工作所需要的类库，而jvm和 lib和起来就称为jre。JDK是整个JAVA的核心，包括了Java运行环境JRE（Java Runtime Envirnment）、一堆Java工具（javac/java/jdb等）和Java基础的类库（即Java API 包括rt.jar）。 Java Runtime Environment（JRE）&ensp;&ensp;是运行基于Java语言编写的程序所不可缺少的运行环境。也是通过它，Java的开发者才得以将自己开发的程序发布到用户手中，让用户使用。&ensp;&ensp;RE中包含了Java virtual machine（JVM），runtime class libraries和Java application launcher，这些是运行Java程序的必要组件。&ensp;&ensp;与大家熟知的JDK不同，JRE是Java运行环境，并不是一个开发环境，所以没有包含任何开发工具（如编译器和调试器），只是针对于使用Java程序的用户。 JVM（java virtual machine）&ensp;&ensp;就是我们常说的java虚拟机，它是整个java实现跨平台的最核心的部分，所有的java程序会首先被编译为.class的类文件，这种类文件可以在虚拟机上执行。 最后&ensp;&ensp;上面的答案都是百度来的！","tags":[{"name":"java","slug":"java","permalink":"http://lj360560179.github.io/tags/java/"}]},{"title":"2016.8.17","date":"2016-08-16T16:34:14.000Z","path":"2016/08/17/面试记录/","text":"1.事务&ensp;&ensp;&ensp;&ensp;事务(Transaction)是访问并可能更新数据库中各种数据项的一个程序执行单元(unit)。事务通常由高级数据库操纵语言或编程语言（如SQL，C++或Java）书写的用户程序的执行所引起，并用形如begin transaction和end transaction语句（或函数调用）来界定。事务由事务开始(begin transaction)和事务结束(end transaction)之间执行的全体操作组成。（抄百度的）事务是恢复和并发控制的基本单位。四个特性&ensp;&ensp;&ensp;&ensp;事务应该具有4个属性：原子性、一致性、隔离性、持续性。这四个属性通常称为ACID特性。&ensp;&ensp;&ensp;&ensp;原子性（atomicity）。一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。&ensp;&ensp;&ensp;&ensp;一致性（consistency）。事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。&ensp;&ensp;&ensp;&ensp;隔离性（isolation）。一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。&ensp;&ensp;&ensp;&ensp;持久性（durability）。持续性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。 2.乐观锁和悲观锁&ensp;&ensp;&ensp;&ensp;悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。&ensp;&ensp;&ensp;&ensp;乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。 init-method/destroy-method&ensp;&ensp;&ensp;&ensp;在spring 容器初始化 bean 和销毁前所做的操作。定义方式有三种。&ensp;&ensp;&ensp;&ensp;第一种：通过@PostConstruct 和 @PreDestroy 方法 实现初始化和销毁bean之前进行的操作&ensp;&ensp;&ensp;&ensp;第二种是：通过 在xml中定义init-method 和 destory-method方法&ensp;&ensp;&ensp;&ensp;第三种是： 通过bean实现InitializingBean和 DisposableBean接口 &ensp;&ensp;&ensp;&ensp;在xml中配置 init-method和 destory-method方法&ensp;&ensp;&ensp;&ensp;只是定义spring 容器在初始化bean 和容器销毁之前的所做的操作&ensp;&ensp;&ensp;&ensp;基于xml的配置只是一种方式：12&lt;bean id=\"XXXXXXService\" class=\"com.XXX.XXXService\" scope=\"singleton\" init-method=\"初始方法\" destroy-method=\"销毁方法\"&gt; &lt;/bean&gt; &ensp;&ensp;&ensp;&ensp;其中如果在中指定Bean的作用范围为scope=”prototype”,将Bean返回给调用者,调用者负责Bean后续生命的管理,spring不再管理这些Bean的生命周期.如果作用范围设置为scope=”singleton”,则将Bean放入SpringIOC容器的缓存池中,并将Bean引用返回给调用者,spring继续对这些Bean进行后续的生命管理.默认属性是singleton。&ensp;&ensp;&ensp;&ensp;Bean以两种形态存在：singletons形式和prototypes形式。当bean以singletons形态存在时，BeanFactory只管理一个共享的实例。所有对这个特定bean的实例请求，都导致返回这个唯一bean实例的引用。当bean以prototype形态存在时，每次对这个bean的实例请求都会导致一个新的实例的创建。当用户需要不受其他用户对象影响的对象或有类似的需求时，这是一个较理想的解决办法。Bean默认是以singleton形态存在的，除非你另外显式加以指定。留神，当把bean的设置改为prototype模式时，每次对这个bean的实例请求都会导致一个新的bean实例被创建，而这可能并不是你所期望的。所以，只应该在确实需要的情况下把bean设置为prototype模式 4.给你一个字段，怎么查找是数据库中的那张表1select table_name from dba_tab_columns where column_name='字段名（大写）' 5.springMVC中controller是不是单例的，怎么变成多例&ensp;&ensp;&ensp;&ensp;为了性能，Spring Mvc默认是单例的。但是也可以设置成多例，在controller添加@Scope(“prototype”)注解。因此不要在controller中定义成员变量，万一必须要定义一个非静态成员变量时候，则通过注解@Scope(“prototype”)，将其设置为多例模式。 6.Spring什么时候实例化bean首先要分2种情况&ensp;&ensp;&ensp;&ensp;第一：如果你使用BeanFactory作为Spring Bean的工厂类，则所有的bean都是在第一次使用该Bean的时候实例化&ensp;&ensp;&ensp;&ensp;第二：如果你使用ApplicationContext作为Spring Bean的工厂类，则又分为以下几种情况：&ensp;&ensp;&ensp;&ensp;（1）：如果bean的scope是singleton的，并且lazy-init为false（默认是false，所以可以不用设置），则ApplicationContext启动的时候就实例化该Bean，并且将实例化的Bean放在一个map结构的缓存中，下次再使用该Bean的时候，直接从这个缓存中取&ensp;&ensp;&ensp;&ensp;（2）：如果bean的scope是singleton的，并且lazy-init为true，则该Bean的实例化是在第一次使用该Bean的时候进行实例化&ensp;&ensp;&ensp;&ensp;（3）：如果bean的scope是prototype的，则该Bean的实例化是在第一次使用该Bean的时候进行实例化","tags":[{"name":"java","slug":"java","permalink":"http://lj360560179.github.io/tags/java/"}]},{"title":"Spring Boot + Spring-data-jpa简单例子","date":"2016-07-25T07:44:14.000Z","path":"2016/07/25/SpringBoot+Spring-data-jpa/","text":"Spring Boot + Spring-data-jpa这两个框架都没用过，平时上网查资料听的也比较多，有时间就自己整合一下，关于Spring Boot，这里有很多跟其他框架整合的例子。 1.SpringBoot基础项目先把Spring boot的基础项目跑起来。参考两个大神的博客这里1和这里2,第二个大神的博客里面有很多关于springboot的文章，包括Spring Boot + Spring-data-jpa首先新建一个maven基础项目，可以通过idea也可以通过命令新建1mvn archetype:generate -DgroupId=springboot -DartifactId=springboot-example -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false 2.SpringBoot pom.xml123456789101112131415161718192021222324252627282930313233&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;springboot-example&lt;/groupId&gt; &lt;artifactId&gt;springboot-example&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;springboot-example Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;!-- Inherit defaults from Spring Boot --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.3.3.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;!-- Spring Boot web依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;springboot-example&lt;/finalName&gt; &lt;/build&gt;&lt;/project&gt; 3.新建一个实体entity1234567891011121314151617181920212223242526272829303132333435363738394041package com.lj.entity;/** * Created by LJ on 2016/8/2. * */public class User &#123; private Long id; private String name; private Integer age; public User()&#123;&#125; public User(String name, Integer age) &#123; this.name = name; this.age = age; &#125; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125;&#125; 4.controller1234567891011121314151617181920212223242526272829303132package com.lj.controller;import com.lj.entity.User;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.ArrayList;import java.util.List;/** * Created by LJ on 2016/8/2. */@RestController@RequestMapping(\"/user\")public class UserController &#123; /** * 测试添加用户 * @param id * @return */ @RequestMapping(\"/&#123;id&#125;\") public User view(@PathVariable(\"id\") Long id) &#123; Integer i = new Integer(Long.toString(id)); User user = new User(); user.setName(\"zhang\"); user.setAge(i); userRepository.save(user); return user; &#125;&#125; 5.启动应用类Application.java123456789101112131415161718package com.lj;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.EnableAutoConfiguration;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;/** * Created by LJ on 2016/8/2. */@Configuration@ComponentScan@EnableAutoConfigurationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class); &#125;&#125; 此时 右键运行Application，在浏览器中输入localhost:8080/user/1就可以看到返回的user。 6.加入Spring-data-jpa修改pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;springboot-example&lt;/groupId&gt; &lt;artifactId&gt;springboot-example&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;springboot-example Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;!-- Inherit defaults from Spring Boot --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.3.3.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;!-- Spring Boot web依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.21&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;springboot-example&lt;/finalName&gt; &lt;/build&gt;&lt;/project&gt; 修改user.java。添加注解1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.lj.entity;import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.Id;/** * Created by LJ on 2016/8/2. * */@Entitypublic class User &#123; @Id @GeneratedValue private Long id; @Column(nullable = false) private String name; @Column(nullable = false) private Integer age; public User()&#123;&#125; public User(String name, Integer age) &#123; this.name = name; this.age = age; &#125; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125;&#125; 修改controller方便测试。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.lj.controller;import com.lj.entity.User;import com.lj.entity.UserRepository;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.ArrayList;import java.util.List;/** * Created by LJ on 2016/8/2. */@RestController@RequestMapping(\"/user\")public class UserController &#123; @Autowired private UserRepository userRepository; /** * 测试添加用户 * @param id * @return */ @RequestMapping(\"/&#123;id&#125;\") public User view(@PathVariable(\"id\") Long id) &#123; Integer i = new Integer(Long.toString(id)); User user = new User(); user.setName(\"zhang\"); user.setAge(i); userRepository.save(user); return user; &#125; /** * 测试查找所有用户 * @return */ @RequestMapping(\"/list\") public List&lt;User&gt; list() &#123; List&lt;User&gt; list = new ArrayList&lt;User&gt;(); list = userRepository.findAll(); return list; &#125; /** * 测试通过名字查找用户 * @param name * @return */ @RequestMapping(\"/name/&#123;name&#125;\") public User name(@PathVariable(\"name\") String name)&#123; User user = userRepository.findByName(name); return user; &#125;&#125; 7.resources下新建配置文件application.properties123456spring.datasource.url=jdbc:mysql://localhost:3306/springbootspring.datasource.username=rootspring.datasource.password=110110spring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.jpa.properties.hibernate.hbm2ddl.auto=create-drop 根据自己情况修改帐号密码 spring.jpa.properties.hibernate.hbm2ddl.auto=create-drop是hibernate的配置参数create：表示启动的时候先drop，再createcreate-drop: 也表示创建，只不过再系统关闭前执行一下dropupdate: 这个操作启动的时候会去检查schema是否一致，如果不一致会做scheme更新更多详细的可以去网上查找资料 8.JpaRepository123456789101112131415161718package com.lj.entity;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.jpa.repository.Query;import org.springframework.data.repository.query.Param;/** * Created by LJ on 2016/8/3. */public interface UserRepository extends JpaRepository&lt;User, Long&gt;&#123; User findByName(String name); User findByNameAndAge(String name, Integer age); @Query(\"from User u where u.name=:name\") User findUser(@Param(\"name\") String name);&#125; 这样就完成了，启动Application，打开controller相应的连接就能看到返回结果。 最后放上源码地址","tags":[{"name":"java","slug":"java","permalink":"http://lj360560179.github.io/tags/java/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://lj360560179.github.io/tags/Spring-Boot/"},{"name":"Spring-data-jpa","slug":"Spring-data-jpa","permalink":"http://lj360560179.github.io/tags/Spring-data-jpa/"}]},{"title":"Spring+activemq","date":"2016-07-25T07:44:14.000Z","path":"2016/07/25/spring+activemq/","text":"1.新建项目1mvn archetype:generate -DgroupId=springboot -DartifactId=springboot-example -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false 2.pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;spring-acticemq&lt;/groupId&gt; &lt;artifactId&gt;spring-acticemq&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring-acticemq Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;!-- 使用junit4.0 --&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--Spring--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring test--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- activemq --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-all&lt;/artifactId&gt; &lt;version&gt;5.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-pool&lt;/artifactId&gt; &lt;version&gt;5.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jms&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;spring-acticemq&lt;/finalName&gt; &lt;/build&gt;&lt;/project&gt; 3.spring-activemq.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:amq=\"http://activemq.apache.org/schema/core\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://activemq.apache.org/schema/core http://activemq.apache.org/schema/core/activemq-core-5.8.0.xsd\"&gt; &lt;!-- Activemq 连接工厂 --&gt; &lt;bean id=\"activeMQConnectionFactory\" class=\"org.apache.activemq.ActiveMQConnectionFactory\"&gt; &lt;constructor-arg value=\"system1\" /&gt; &lt;constructor-arg value=\"manager1\" /&gt; &lt;constructor-arg value=\"failover:(tcp://localhost:61616)?timeout=10000\" /&gt; &lt;/bean&gt; &lt;!-- ConnectionFactory Definition --&gt; &lt;bean id=\"connectionFactory\" class=\"org.springframework.jms.connection.CachingConnectionFactory\"&gt; &lt;constructor-arg ref=\"activeMQConnectionFactory\" /&gt; &lt;/bean&gt; &lt;!-- Default Destination Queue Definition --&gt; &lt;!-- 测试配置多个Destination --&gt; &lt;!-- P2P START--&gt; &lt;bean id=\"queueDestination\" class=\"org.apache.activemq.command.ActiveMQQueue\"&gt; &lt;!-- 设置消息队列的名字 --&gt; &lt;constructor-arg&gt; &lt;value&gt;testSpringQueue&lt;/value&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!-- topic--&gt; &lt;bean id=\"topicDestination\" class=\"org.apache.activemq.command.ActiveMQTopic\"&gt; &lt;!-- 设置消息队列的名字 --&gt; &lt;constructor-arg&gt; &lt;value&gt;testSpringTopic&lt;/value&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!-- 配置JMS模板（Queue），Spring提供的JMS工具类，它发送、接收消息。 --&gt; &lt;bean id=\"jmsTemplateQueue\" class=\"org.springframework.jms.core.JmsTemplate\"&gt; &lt;property name=\"connectionFactory\" ref=\"connectionFactory\" /&gt; &lt;property name=\"defaultDestination\" ref=\"queueDestination\" /&gt; &lt;property name=\"receiveTimeout\" value=\"10000\" /&gt; &lt;/bean&gt; &lt;!-- 配置JMS模板（Topic），Spring提供的JMS工具类，它发送、接收消息。 --&gt; &lt;bean id=\"jmsTemplateTopic\" class=\"org.springframework.jms.core.JmsTemplate\"&gt; &lt;property name=\"connectionFactory\" ref=\"connectionFactory\" /&gt; &lt;property name=\"defaultDestination\" ref=\"topicDestination\" /&gt; &lt;property name=\"receiveTimeout\" value=\"10000\" /&gt; &lt;/bean&gt; &lt;!-- Message Sender Definition --&gt; &lt;!-- Queue--&gt; &lt;bean id=\"messageSender\" class=\"com.lj.activemq.publisher.MessageSender\"&gt; &lt;constructor-arg index=\"0\" ref=\"jmsTemplateQueue\" /&gt; &lt;constructor-arg index=\"1\" ref=\"queueDestination\" /&gt; &lt;/bean&gt; &lt;!-- Message Sender Definition --&gt; &lt;!-- Topic--&gt; &lt;bean id=\"messageSenderTopic\" class=\"com.lj.activemq.publisher.MessageSenderTopic\"&gt; &lt;constructor-arg index=\"0\" ref=\"jmsTemplateTopic\" /&gt; &lt;constructor-arg index=\"1\" ref=\"topicDestination\" /&gt; &lt;/bean&gt; &lt;!-- 配置消息消费监听者 --&gt; &lt;!-- Queue--&gt; &lt;bean id=\"consumerMessageListenerQueue\" class=\"com.lj.activemq.consumer.MessageReceiver\" /&gt; &lt;!-- 消息监听容器，配置连接工厂,监听器是上面定义的监听器 --&gt; &lt;bean id=\"jmsContainerQueue\" class=\"org.springframework.jms.listener.DefaultMessageListenerContainer\"&gt; &lt;property name=\"connectionFactory\" ref=\"connectionFactory\" /&gt; &lt;property name=\"destination\" ref=\"queueDestination\" /&gt; &lt;!--主题（Topic）和队列消息的主要差异体现在JmsTemplate中\"pubSubDomain\"是否设置为True。如果为True，则是Topic；如果是false或者默认，则是queue--&gt; &lt;property name=\"pubSubDomain\" value=\"false\" /&gt; &lt;property name=\"messageListener\" ref=\"consumerMessageListenerQueue\" /&gt; &lt;/bean&gt; &lt;!-- 配置消息消费监听者 --&gt; &lt;!-- Topic--&gt; &lt;bean id=\"consumerMessageListenerTopic\" class=\"com.lj.activemq.consumer.MessageReceiverTopic1\" /&gt; &lt;bean id=\"consumerMessageListenerTopic2\" class=\"com.lj.activemq.consumer.MessageReceiverTopic2\" /&gt; &lt;!-- 消息监听容器，配置连接工厂,监听器是上面定义的监听器 --&gt; &lt;bean id=\"jmsContainer\" class=\"org.springframework.jms.listener.DefaultMessageListenerContainer\"&gt; &lt;property name=\"connectionFactory\" ref=\"connectionFactory\" /&gt; &lt;property name=\"destination\" ref=\"topicDestination\" /&gt; &lt;!--主题（Topic）和队列消息的主要差异体现在JmsTemplate中\"pubSubDomain\"是否设置为True。如果为True，则是Topic；如果是false或者默认，则是queue--&gt; &lt;property name=\"pubSubDomain\" value=\"true\" /&gt; &lt;property name=\"messageListener\" ref=\"consumerMessageListenerTopic\" /&gt; &lt;/bean&gt; &lt;bean id=\"jmsContainer2\" class=\"org.springframework.jms.listener.DefaultMessageListenerContainer\"&gt; &lt;property name=\"connectionFactory\" ref=\"connectionFactory\" /&gt; &lt;property name=\"destination\" ref=\"topicDestination\" /&gt; &lt;!--主题（Topic）和队列消息的主要差异体现在JmsTemplate中\"pubSubDomain\"是否设置为True。如果为True，则是Topic；如果是false或者默认，则是queue--&gt; &lt;property name=\"pubSubDomain\" value=\"true\" /&gt; &lt;property name=\"messageListener\" ref=\"consumerMessageListenerTopic2\" /&gt; &lt;/bean&gt;&lt;/beans&gt; 4.publisher1234567891011121314151617181920212223242526272829303132package com.lj.activemq.publisher;import org.springframework.jms.core.JmsTemplate;import javax.jms.Destination;/** * Created by LJ on 2016/8/27. *//** * Created by LJ on 2016/8/25. */public class MessageSender &#123; private final JmsTemplate jmsTemplate; private final Destination destination; public MessageSender(final JmsTemplate jmsTemplate, final Destination destination) &#123; this.jmsTemplate = jmsTemplate; this.destination = destination; &#125; public void send(final String text) &#123; try &#123; jmsTemplate.setDefaultDestination(destination); jmsTemplate.convertAndSend(text); System.out.println(\"发送消息 : \" + text); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 5.consumer1234567891011121314151617181920212223package com.lj.activemq.consumer;import javax.jms.JMSException;import javax.jms.Message;import javax.jms.MessageListener;import javax.jms.TextMessage;/** * Created by LJ on 2016/8/27. */public class MessageReceiver implements MessageListener&#123; public void onMessage(Message message) &#123; if (message instanceof TextMessage) &#123; TextMessage textMessage = (TextMessage) message; try &#123; String text = textMessage.getText(); System.out.println(\"点对点消费者接收到消息: \" + text); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 地址地址","tags":[{"name":"java","slug":"java","permalink":"http://lj360560179.github.io/tags/java/"},{"name":"Spring","slug":"Spring","permalink":"http://lj360560179.github.io/tags/Spring/"},{"name":"activemq","slug":"activemq","permalink":"http://lj360560179.github.io/tags/activemq/"}]},{"title":"百度推送连接","date":"2016-07-19T04:34:14.000Z","path":"2016/07/19/Baidu/","text":"很久前 参考 网上列子 写的一个把连接推送到百度东西 相关代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * @param args */ public static void Curlpost(String path) &#123; String url = \"http://data.zz.baidu.com/urls?site=www.example.com&amp;token=xxxxxxxxx&amp;type=original\";//网站的服务器连接 String[] param = &#123; \"http://www.example.com/\"+path+\"\"//需要推送的网址 &#125;; String json = Post(url, param);//执行推送方法 System.out.println(\"结果是\"+json); //打印推送结果 &#125; /** * 百度链接实时推送 * @param PostUrl * @param Parameters * @return */ public static String Post(String PostUrl,String[] Parameters)&#123; if(null == PostUrl || null == Parameters || Parameters.length ==0)&#123; return null; &#125; String result=\"\"; PrintWriter out=null; BufferedReader in=null; try &#123; //建立URL之间的连接 URLConnection conn=new URL(PostUrl).openConnection(); //设置通用的请求属性 conn.setRequestProperty(\"Host\",\"data.zz.baidu.com\"); conn.setRequestProperty(\"User-Agent\", \"curl/7.12.1\"); conn.setRequestProperty(\"Content-Length\", \"83\"); conn.setRequestProperty(\"Content-Type\", \"text/plain\"); //发送POST请求必须设置如下两行 conn.setDoInput(true); conn.setDoOutput(true); //获取conn对应的输出流 out=new PrintWriter(conn.getOutputStream()); //发送请求参数 String param = \"\"; for(String s : Parameters)&#123; param += s+\"\\n\"; &#125; out.print(param.trim()); //进行输出流的缓冲 out.flush(); //通过BufferedReader输入流来读取Url的响应 in=new BufferedReader(new InputStreamReader(conn.getInputStream())); String line; while((line=in.readLine())!= null)&#123; result += line; &#125; &#125; catch (Exception e) &#123; System.out.println(\"发送post请求出现异常！\"+e); e.printStackTrace(); &#125; finally&#123; try&#123; if(out != null)&#123; out.close(); &#125; if(in!= null)&#123; in.close(); &#125; &#125;catch(IOException ex)&#123; ex.printStackTrace(); &#125; &#125; return result; &#125;","tags":[{"name":"java","slug":"java","permalink":"http://lj360560179.github.io/tags/java/"}]},{"title":"quartz 使用spring @Scheduled注解执行定时任务","date":"2016-06-25T07:44:14.000Z","path":"2016/06/25/quartz 使用spring @Scheduled注解执行定时任务/","text":"quartz 使用spring @Scheduled注解执行定时任务1.maven依赖12345&lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz&lt;/artifactId&gt; &lt;version&gt;1.8.4&lt;/version&gt;&lt;/dependency&gt; 2.spring配置1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:task=\"http://www.springframework.org/schema/task\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task.xsd \"&gt; &lt;task:annotation-driven /&gt; &lt;context:annotation-config /&gt; //配置扫描位置 &lt;context:component-scan base-package=\"org.seckill.quartz\"/&gt;&lt;/beans&gt; xsi:schemaLocation下要加上http://www.springframework.org/schema/taskhttp://www.springframework.org/schema/task/spring-task-3.1.xsd 3.org.seckill.quartz包下的实现类123456789101112131415161718192021222324252627282930313233package org.seckill.quartz;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Component;/** * 业务相关的作业调度 * 字段 允许值 允许的特殊字符 秒 0-59 , - * / 分 0-59 , - * / 小时 0-23 , - * / 日期 1-31 , - * ? / L W C 月份 1-12 或者 JAN-DEC , - * / 星期 1-7 或者 SUN-SAT , - * ? / L C # 年（可选） 留空, 1970-2099 , - * / * 字符代表所有可能的值 / 字符用来指定数值的增量 L 字符仅被用于天（月）和天（星期）两个子表达式，表示一个月的最后一天或者一个星期的最后一天 6L 可以表示倒数第６天 * */@Componentpublic class BizQuartz &#123; /** * 每天9点到17点每过1分钟执行 */ @Scheduled(cron = \"0 0/1 9-17 * * ? \") public void addUserScore() &#123; System.out.print(\"每天9点到17点每过1分钟执行一次\"); &#125;&#125;","tags":[{"name":"java","slug":"java","permalink":"http://lj360560179.github.io/tags/java/"},{"name":"quartz","slug":"quartz","permalink":"http://lj360560179.github.io/tags/quartz/"}]},{"title":"node","date":"2016-05-25T07:44:14.000Z","path":"2016/05/25/Node.js学习（1）/","text":"特点单线程&ensp;&ensp;&ensp;&ensp;node.js不为每个客户连接创建一个新的线程，仅仅使用一个线程，当有用户连接，就促发一个内部事件，通过费阻塞I/O、事件驱动机制，让Node.js程序宏观上也是并行的。而且没有线程创建、销毁的时间开销。 非阻塞I/O&ensp;&ensp;&ensp;&ensp;不会等I/O语句结束，而会执行后面的语句。 事件驱动&ensp;&ensp;&ensp;&ensp;不管是新用户的请求，还是老用户的I/O完成，都将以事件方式加入事件环，等待调度。 适合做什么&ensp;&ensp;&ensp;&ensp;善于I/O，不善于计算。因为Node.js最擅长的就是任务调度，如果你的业务有很多的CPU计算，实际上也相当于这个计算阻塞了这个单线程，就不适合Node开发。","tags":[{"name":"node.js","slug":"node-js","permalink":"http://lj360560179.github.io/tags/node-js/"}]},{"title":"网站icon图标","date":"2016-05-25T04:34:14.000Z","path":"2016/05/25/icon/","text":"网站icon图标之前在学习webpack打包的时候，发现可以将网站ICON图标转化为Base64编码规范的文本字符，然后引入当做背景图片，以前只知道CSS Sprites这种方法来减少网页请求。后来上网了解了一下，原来现在对网站icon已经有了很多优化方法，如： CSS Sprites 字体图标(Icon Font) DataURI SVG Sprites 其核心依然是减少HTPP请求数。 CSS Sprites(雪碧图)现在大部分网站还是使用这种方法优化网站icon，使用方法也非常简单，网上工具很多。这里列举下这种方式的优缺点，不详细说明。优势： 减少HTTP请求数 可以是任意图形，也可以是任意色彩 兼容性极好 劣势： 增加开发时间，增加维护成本，当做好一张图后，想修改是非常麻烦的。 图片尺寸固定 字体图标(Icon Font)为了解决屏幕分辨率对图标影响的问题，字体图标(Icon Font)就顺势而生了。字体图标是一种全新的设计方式，更为重要的是相比位图而言，使用字体图标可以不受限于屏幕分辨率，冲着这一点就具有非常强的优势，而且字体图标还具有一个优势是，只要适合字体相关的CSS属性都适合字体图标，比如说使用font-size修改图标大小、使用color修改图标颜色、使用text-shadow给图标增加阴影等等。基于这些原因，这种方式用的越来越多。优势： 减少HTTP请求数 很容易任意地缩放、改变颜色、产生阴影、可以拥有透明效果、等CSS的支持。 体积小 劣势： 它们只能被渲染成单色或CSS3的渐变色 使用限制性很大，除非你想花时间去创作你自己的字体图标， 字体文件体积过大，直接影响页面加载性能，特别是加载一个包含数百图标的Fonts，却只使用其中几个图标 在不同的设备浏览器字体的渲染会略有差别，在不同的浏览器或系统中对文字的渲染不同，其显示的位置和大小可能会受到font-size、line-height、word-spacing等CSS属性的影响，而且这种影响调整起来较为困难 为了实现最大程度的浏览器支持，可能要提供至少四种不同类型的字体文件。包括.ttf、.woff、.eot和.svg格式字体 不兼容旧的手机浏览器：Opera mini，Android 2.1，Windows Phone 7.5-7.8 在手机上可能与系统字体冲突 下面来尝试用这种方法来制作网站ICON。一般字体库都是在网上找现成的用。如阿里的图标库，还有国外的icomoon.io。 1.从网上下载字体库打开icomoon.io。然后如图 接着 2.下载解压后得到以下文件 3.然后我们新建一个HTML文件要引入下载的style.css 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;font-icon&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;link rel=\"stylesheet\" href=\"style.css\"&gt; &lt;!--[if lt IE 8]&gt;&lt;!--&gt; &lt;link rel=\"stylesheet\" href=\"ie7/ie7.css\"&gt; &lt;!--&lt;![endif]--&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"clearfix mhl ptl\"&gt; &lt;div class=\"clearfix bshadow0 pbs\"&gt; &lt;span class=\"icon icon-home\"&gt; &lt;/span&gt; &lt;span class=\"icon\"&gt;&amp;#xe900; &lt;/span&gt; &lt;/div&gt; &lt;div class=\"clearfix bshadow0 pbs\"&gt; &lt;span class=\"icon icon-office\"&gt; &lt;/span&gt; &lt;span class=\"icon\"&gt;&amp;#xe903; &lt;/span&gt; &lt;/div&gt; &lt;div class=\"clearfix bshadow0 pbs\"&gt; &lt;span class=\"icon icon-newspaper\"&gt; &lt;/span&gt; &lt;span class=\"icon\"&gt;&amp;#xe904; &lt;/span&gt; &lt;/div&gt; &lt;div class=\"clearfix bshadow0 pbs\"&gt; &lt;span class=\"icon icon-pencil\"&gt; &lt;/span&gt; &lt;span class=\"icon\"&gt;&amp;#xe905; &lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 4.style.css如下1234567891011121314151617181920212223242526272829303132333435363738394041424344@font-face &#123; font-family: 'icomoon'; src: url('fonts/icomoon.eot?ri2p4y'); src: url('fonts/icomoon.eot?ri2p4y#iefix') format('embedded-opentype'), url('fonts/icomoon.ttf?ri2p4y') format('truetype'), url('fonts/icomoon.woff?ri2p4y') format('woff'), url('fonts/icomoon.svg?ri2p4y#icomoon') format('svg'); font-weight: normal; font-style: normal;&#125;.icon &#123; /* use !important to prevent issues with browser extensions that change fonts */ font-family: 'icomoon' !important; speak: none; font-style: normal; font-weight: normal; font-variant: normal; text-transform: none; line-height: 1; /* Better Font Rendering =========== */ -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; /* 为演示添加 =========== */ font-size: 40px;&#125;.icon-home:before &#123; content: \"\\e900\";//加入字体编号 font-size: 50px;//修改字体大小&#125;.icon-office:before &#123; content: \"\\e903\"; color: #564813;//修改字体颜色&#125;.icon-newspaper:before &#123; content: \"\\e904\"; font-size: 20px;&#125;.icon-pencil:before &#123; content: \"\\e905\"; color: #444444;&#125; 以上用了两种方式来引用字体文件，一种是通过Html直接写字体编号，另一种通过CSS伪类添加内容。相应的字体编号在下载下来的demo.html中可以查看。 而最终效果如下图，可以在CSS中对相应的字体修改其样式，缩放、改变颜色、产生阴影、可以拥有透明效果、等CSS样式都可以 SVG Sprites(雪碧图)SVG Sprites原理跟CSS Sprites一样，把多个SVG 图标放到一张SVG中，然后通过坐标或者ID获取其中的图标。Icon Font功能的网站icomoon.io已经提供输出 SVG Sprites 功能了。 1.照例从网上下载SVG Sprites跟font一样下载SVG 点击设置，选中CSS SPRITE 2.下载解压后目录如下这也提供了两种方式使用SVG icon,其中sprite文件夹中的跟CSS sprite一样，通过CSS坐标来取不同的SVG图标. 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!-- Generated by IcoMoon.io --&gt;&lt;!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"&gt;&lt;svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"752\" height=\"32\" viewBox=\"0 0 752 32\"&gt;&lt;svg id=\"icon-home\" width=\"32\" height=\"32\" viewBox=\"0 0 32 32\" x=\"0\" y=\"0\"&gt;&lt;path d=\"M32 18.451l-16-12.42-16 12.42v-5.064l16-12.42 16 12.42zM28 18v12h-8v-8h-8v8h-8v-12l12-9z\"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;svg id=\"icon-office\" width=\"32\" height=\"32\" viewBox=\"0 0 32 32\" x=\"48\" y=\"0\"&gt;&lt;path d=\"M0 32h16v-32h-16v32zM10 4h4v4h-4v-4zM10 12h4v4h-4v-4zM10 20h4v4h-4v-4zM2 4h4v4h-4v-4zM2 12h4v4h-4v-4zM2 20h4v4h-4v-4zM18 10h14v2h-14zM18 32h4v-8h6v8h4v-18h-14z\"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;svg id=\"icon-newspaper\" width=\"32\" height=\"32\" viewBox=\"0 0 32 32\" x=\"96\" y=\"0\"&gt;&lt;path d=\"M28 8v-4h-28v22c0 1.105 0.895 2 2 2h27c1.657 0 3-1.343 3-3v-17h-4zM26 26h-24v-20h24v20zM4 10h20v2h-20zM16 14h8v2h-8zM16 18h8v2h-8zM16 22h6v2h-6zM4 14h10v10h-10z\"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;svg id=\"icon-pencil\" width=\"32\" height=\"32\" viewBox=\"0 0 32 32\" x=\"144\" y=\"0\"&gt;&lt;path d=\"M27 0c2.761 0 5 2.239 5 5 0 1.126-0.372 2.164-1 3l-2 2-7-7 2-2c0.836-0.628 1.874-1 3-1zM2 23l-2 9 9-2 18.5-18.5-7-7-18.5 18.5zM22.362 11.362l-14 14-1.724-1.724 14-14 1.724 1.724z\"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/svg&gt; 这是将四个图标合并一起的sprite.svg文件，CSS首先根据class=”icon”引入svg背景，用background-position并根据x跟y值区分每个图标。下面是sprite.css文件以及HTML。1234567891011121314151617181920212223242526272829&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;CSS Sprite&lt;/title&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;link href=\"sprite.css\" rel=\"stylesheet\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"clearfix mhl\"&gt; &lt;div class=\"cell fs1\"&gt; &lt;span class=\"icon icon-home\"&gt;&lt;/span&gt; icon-home &lt;/div&gt; &lt;div class=\"cell fs1\"&gt; &lt;span class=\"icon icon-office\"&gt;&lt;/span&gt; icon-office &lt;/div&gt; &lt;div class=\"cell fs1\"&gt; &lt;span class=\"icon icon-newspaper\"&gt;&lt;/span&gt; icon-newspaper &lt;/div&gt; &lt;div class=\"cell fs1\"&gt; &lt;span class=\"icon icon-pencil\"&gt;&lt;/span&gt; icon-pencil &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425.icon &#123; display: inline-block; background-repeat: no-repeat; background-image: url(sprite.svg);&#125;.icon-home &#123; width: 32px; height: 32px; background-position: 0 0;&#125;.icon-office &#123; width: 32px; height: 32px; background-position: -48px 0;&#125;.icon-newspaper &#123; width: 32px; height: 32px; background-position: -96px 0;&#125;.icon-pencil &#123; width: 32px; height: 32px; background-position: -144px 0;&#125; 3.SVG Sprite与symbol元素目前，SVG Sprite最佳实践是使用symbol元素。symbol元素是什么呢？单纯翻译的话，是“符号”的意思。然，这个释义并不符合这里的场景。用组件解释比较合适。SVG就是由许多个symbol组合起来的。下面就是从下载的demo中的svg，由四个symbol组合而成：1234567891011121314151617181920&lt;svg style=\"position: absolute; width: 0; height: 0; overflow: hidden;\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"&gt;&lt;defs&gt; &lt;symbol id=\"icon-home\" viewBox=\"0 0 32 32\"&gt; &lt;title&gt;home&lt;/title&gt; &lt;path class=\"path1\" d=\"M32 18.451l-16-12.42-16 12.42v-5.064l16-12.42 16 12.42zM28 18v12h-8v-8h-8v8h-8v-12l12-9z\"&gt;&lt;/path&gt; &lt;/symbol&gt; &lt;symbol id=\"icon-office\" viewBox=\"0 0 32 32\"&gt; &lt;title&gt;office&lt;/title&gt; &lt;path class=\"path1\" d=\"M0 32h16v-32h-16v32zM10 4h4v4h-4v-4zM10 12h4v4h-4v-4zM10 20h4v4h-4v-4zM2 4h4v4h-4v-4zM2 12h4v4h-4v-4zM2 20h4v4h-4v-4zM18 10h14v2h-14zM18 32h4v-8h6v8h4v-18h-14z\"&gt;&lt;/path&gt; &lt;/symbol&gt; &lt;symbol id=\"icon-newspaper\" viewBox=\"0 0 32 32\"&gt; &lt;title&gt;newspaper&lt;/title&gt; &lt;path class=\"path1\" d=\"M28 8v-4h-28v22c0 1.105 0.895 2 2 2h27c1.657 0 3-1.343 3-3v-17h-4zM26 26h-24v-20h24v20zM4 10h20v2h-20zM16 14h8v2h-8zM16 18h8v2h-8zM16 22h6v2h-6zM4 14h10v10h-10z\"&gt;&lt;/path&gt; &lt;/symbol&gt; &lt;symbol id=\"icon-pencil\" viewBox=\"0 0 32 32\"&gt; &lt;title&gt;pencil&lt;/title&gt; &lt;path class=\"path1\" d=\"M27 0c2.761 0 5 2.239 5 5 0 1.126-0.372 2.164-1 3l-2 2-7-7 2-2c0.836-0.628 1.874-1 3-1zM2 23l-2 9 9-2 18.5-18.5-7-7-18.5 18.5zM22.362 11.362l-14 14-1.724-1.724 14-14 1.724 1.724z\"&gt;&lt;/path&gt; &lt;/symbol&gt;&lt;/defs&gt;&lt;/svg&gt; 每一个symbol就是一个图标元件，但是，只有上面的代码，是无法呈现图标效果的,必须要配合use,也就是SVG中的元素。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 &lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;IcoMoon - SVG Icons&lt;/title&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;&lt;/head&gt;&lt;body&gt;&lt;svg style=\"position: absolute; width: 0; height: 0; overflow: hidden;\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"&gt;&lt;defs&gt; &lt;symbol id=\"icon-home\" viewBox=\"0 0 32 32\"&gt; &lt;title&gt;home&lt;/title&gt; &lt;path class=\"path1\" d=\"M32 18.451l-16-12.42-16 12.42v-5.064l16-12.42 16 12.42zM28 18v12h-8v-8h-8v8h-8v-12l12-9z\"&gt;&lt;/path&gt; &lt;/symbol&gt; &lt;symbol id=\"icon-office\" viewBox=\"0 0 32 32\"&gt; &lt;title&gt;office&lt;/title&gt; &lt;path class=\"path1\" d=\"M0 32h16v-32h-16v32zM10 4h4v4h-4v-4zM10 12h4v4h-4v-4zM10 20h4v4h-4v-4zM2 4h4v4h-4v-4zM2 12h4v4h-4v-4zM2 20h4v4h-4v-4zM18 10h14v2h-14zM18 32h4v-8h6v8h4v-18h-14z\"&gt;&lt;/path&gt; &lt;/symbol&gt; &lt;symbol id=\"icon-newspaper\" viewBox=\"0 0 32 32\"&gt; &lt;title&gt;newspaper&lt;/title&gt; &lt;path class=\"path1\" d=\"M28 8v-4h-28v22c0 1.105 0.895 2 2 2h27c1.657 0 3-1.343 3-3v-17h-4zM26 26h-24v-20h24v20zM4 10h20v2h-20zM16 14h8v2h-8zM16 18h8v2h-8zM16 22h6v2h-6zM4 14h10v10h-10z\"&gt;&lt;/path&gt; &lt;/symbol&gt; &lt;symbol id=\"icon-pencil\" viewBox=\"0 0 32 32\"&gt; &lt;title&gt;pencil&lt;/title&gt; &lt;path class=\"path1\" d=\"M27 0c2.761 0 5 2.239 5 5 0 1.126-0.372 2.164-1 3l-2 2-7-7 2-2c0.836-0.628 1.874-1 3-1zM2 23l-2 9 9-2 18.5-18.5-7-7-18.5 18.5zM22.362 11.362l-14 14-1.724-1.724 14-14 1.724 1.724z\"&gt;&lt;/path&gt; &lt;/symbol&gt;&lt;/defs&gt;&lt;/svg&gt;&lt;header class=\"bgc1 clearfix\"&gt;&lt;/header&gt; &lt;div class=\"clearfix mhl ptl\"&gt; &lt;div class=\"glyph fs1\"&gt; &lt;div class=\"clearfix pbs\"&gt; &lt;svg class=\"icon icon-home\"&gt;&lt;use xlink:href=\"#icon-home\"&gt;&lt;/use&gt;&lt;/svg&gt;&lt;span class=\"mls\"&gt; icon-home&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"glyph fs1\"&gt; &lt;div class=\"clearfix pbs\"&gt; &lt;svg class=\"icon icon-office\"&gt;&lt;use xlink:href=\"#icon-office\"&gt;&lt;/use&gt;&lt;/svg&gt;&lt;span class=\"mls\"&gt; icon-office&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"glyph fs1\"&gt; &lt;div class=\"clearfix pbs\"&gt; &lt;svg class=\"icon icon-newspaper\"&gt;&lt;use xlink:href=\"#icon-newspaper\"&gt;&lt;/use&gt;&lt;/svg&gt;&lt;span class=\"mls\"&gt; icon-newspaper&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"glyph fs1\"&gt; &lt;div class=\"clearfix pbs\"&gt; &lt;svg class=\"icon icon-pencil\"&gt;&lt;use xlink:href=\"#icon-pencil\"&gt;&lt;/use&gt;&lt;/svg&gt;&lt;span class=\"mls\"&gt; icon-pencil&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;script defer src=\"svgxuse.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上面就是一个页面中用symbol方式使用图标的代码。效果如下图 SVG也可以独立出来，use的href把路径带上就可以了。 4.多个SVG合成SVG SPRITES如果设计师自己设计并生成了单个SVG图标，合并的方法有两种： icoMoon网站上传后一起导出如图所示，接下来操作跟之前的一样，选中图标后导出就行了。 grunt-svgstore合并利用grunt-svgstore插件合成，有前端经验的都应该知道，grunt我也没用过，想了解的可以上网去查查，grunt是基于node的，所以要先安装node。这块我就不多说了。 1.安装相关资源1npm install -g grunt-cli 首先全局安装CLI，这条命令将会把grunt命令植入系统路径，这样就能在任意目录运行他。1npm install grunt-svgstore --save-dev 2.package.json新建一个文件夹放项目，然后安装grunt-svgstore插件。安装好后node_modules中就有grunt-svgstore相关包了。然后新建package.json文件。123456789&#123; \"name\": \"svg-store\", \"version\": \"0.1.0\", \"private\": true, \"devDependencies\": &#123; \"grunt\": \"^0.4.5\", \"grunt-svgstore\": \"~0.5.0\" &#125;&#125; 然后install依赖。1npm install 3.Gruntfile.js新建配置文件Gruntfile.js12345678910111213141516171819202122232425module.exports = function(grunt) &#123; // 配置 grunt.initConfig(&#123; svgstore: &#123; options: &#123; prefix : 'icon-', svg: &#123; viewBox : '0 0 100 100', xmlns: 'http://www.w3.org/2000/svg' &#125;, includedemo:true, &#125;, default : &#123; files: &#123; 'dest/dest-svg.svg': ['src/*.svg'], &#125;, &#125; &#125; &#125;); // 载入grunt-svgstore grunt.loadNpmTasks('grunt-svgstore'); // 注册任务 grunt.registerTask('default', ['svgstore']);&#125;; 4.新建src文件夹新建src文件夹，把所有的svg文件放进去。然后运行1grunt 在项目目录中就会出现dest-svg.svg跟dest-svg-demo.html，dest-svg.svg就是合并后的svg文件。这里 是这个简单项目的地址。 DataURIDataURI是利用Base64编码规范将图片转换成文本字符，不仅是图片，还可以编码JS、CSS、HTML等文件。通过将图标文件编码成文本字符，从而可以直接写在HTML/CSS文件里面，不会增加任何多余的请求。 但是DataURI的劣势也是很明显的，每次都需要解码从而阻塞了CSS渲染，可以通过分离出一个专用的CSS文件，不过那就需要增加一个请求，那样与CSS Sprites、Icon Font和SVG相比没有了任何优势，也因此，在实践中不推荐这种方法。需要注意的是通过缓存CSS可以来达到缓存的目的。优势： 不增加请求数 劣势： 图片不能太大 每次加载页面都需要解码 不支持IE6/7，IE8最大支持32KB 难于维护 用法很简单，将base64填入即可。123.icon&#123; background: url(data:text/svg+xml;base64,&lt;base64 encoded data&gt;)&#125; 如何选择 如果你需要信息更丰富的图片，不仅仅是图标时，可以考虑使用 使用的不是展示类图形，而是装饰性的图形（包括图标），而且这部分图形一般不轻意改变，可以考虑使用PNG Sprites 如果你的图标之类需要更好的适配于高分辨率设备环境之下，可以考虑使用SVG Sprites 如果仅仅是要使用Icon这些小图标，并且对Icon做一些个性化样式，可以考虑使用Icon Font 如果你需要图标更具扩展性，又不希望加载额外的图标，可以考虑在页面中直接使用SVG代码绘制的矢量图 当然配合起来用也是可以的。 最后这是我参考了网上很多大神的博客写的，一下写了那么长，有错的地方大家见谅。 参考链接【grunt整合版】30分钟学会使用grunt打包前端代码Web中的图标未来必热：SVG Sprite技术介绍Web 设计新趋势: 使用 SVG 代替 Web Icon Font慕课网视频教程：用字体在网页中画ICON图标","tags":[{"name":"css3 node","slug":"css3-node","permalink":"http://lj360560179.github.io/tags/css3-node/"}]},{"title":"微信登录工具","date":"2016-04-25T07:44:14.000Z","path":"2016/04/25/Wechat/","text":"之前做微信登录的时候，看文档写的获取信息的工具类。微信登录就是传过去信息，然后返回信息，然后再根据返回的信息再传过去信息，然后再返回······，最后得到用户信息。 相关代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117 /** * 通过code获取access_token *@param appId * appId * @param appSecret * appSecret * @param code * code * */ @SuppressWarnings(\"unchecked\") public static Map&lt;String, Object&gt; GetWexinAccessToken(String appid,String secret,String code)&#123; Map&lt;String, Object&gt; parameterMap = new HashMap&lt;String, Object&gt;(); parameterMap.put(\"appid\", appid); parameterMap.put(\"secret\", secret); parameterMap.put(\"code\", code); parameterMap.put(\"grant_type\", \"authorization_code\"); String url=\"https://api.weixin.qq.com/sns/oauth2/access_token\"; //发送请求并返回数据 String result = HttpRequest.get(url,parameterMap); if (result.contains(\"errcode\"))&#123; return null; &#125;else&#123; Map&lt;String, Object&gt; model = JsonUtils.toObject(result, Map.class); return model; &#125; &#125; /** * 根据access_token判断access_token是否过期 *@param access_token * access_token * @param openid * Opened * */ @SuppressWarnings(\"unchecked\") public static boolean CheckAccessToken(String access_token,String openid)&#123; Map&lt;String, Object&gt; parameterMap = new HashMap&lt;String, Object&gt;(); parameterMap.put(\"access_token\", access_token); parameterMap.put(\"openid\", openid); String url = \"https://api.weixin.qq.com/sns/auth\"; String result = HttpRequest.get(url,parameterMap); Map&lt;String, Object&gt; model = JsonUtils.toObject(result, Map.class); if(model.containsKey(\"errmsg\"))&#123; if (model.get(\"errmsg\").equals(\"ok\"))&#123; return true; &#125;else &#123; return false; &#125; &#125;else&#123; return false; &#125; &#125; /** * 刷新或续期access_token使用 *@param access_token * access_token * @param openid * Opened * */ @SuppressWarnings(\"unchecked\") public static Map&lt;String, Object&gt; GetRefreshToken(String refresh_token,String appid)&#123; Map&lt;String, Object&gt; parameterMap = new HashMap&lt;String, Object&gt;(); parameterMap.put(\"refresh_token\", refresh_token); parameterMap.put(\"appid\", appid); parameterMap.put(\"grant_type\", \"refresh_token\"); String url = \"https://api.weixin.qq.com/sns/oauth2/refresh_token\"; String result = HttpRequest.get(url,parameterMap); if (result.contains(\"errmsg\"))&#123; return null; &#125;else &#123; Map&lt;String, Object&gt; model = JsonUtils.toObject(result, Map.class); return model; &#125;&#125; /** *获取登录信息 *@param access_token * access_token * @param openid * Opened * */ @SuppressWarnings(\"unchecked\") public static Map&lt;String, Object&gt; GetUserInfo(String access_token, String openid)&#123; Map&lt;String, Object&gt; parameterMap = new HashMap&lt;String, Object&gt;(); parameterMap.put(\"access_token\", access_token); parameterMap.put(\"openid\", openid); String url=\"https://api.weixin.qq.com/sns/userinfo\"; String result = HttpRequest.get(url,parameterMap); if (result.contains(\"errmsg\"))&#123; return null; &#125; Map&lt;String, Object&gt; model = JsonUtils.toObject(result, Map.class); return model;&#125;","tags":[{"name":"java","slug":"java","permalink":"http://lj360560179.github.io/tags/java/"}]}]